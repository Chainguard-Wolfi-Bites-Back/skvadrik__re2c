#include "src/parse/conf_parser.h"
const char* DEFAULT_SYNTAX_HASKELL =
    "supported_apis = [\"record\", \"generic\"];\n"
    "supported_api_styles = [\"free-form\"];\n"
    "supported_code_models = [\"recursive_functions\"];\n"
    "supported_targets = [\"code\", \"dot\"];\n"
    "supported_features = [\"nested_ifs\", \"monadic\"];\n"
    "\n"
    "semicolons = 1;\n"
    "//semicolons = 0;\n"
    "implicit_bool_conversion = 0;\n"
    "backtick_quoted_strings = 0;\n"
    "standalone_single_quotes = 1; // TODO: what about identifiers?\n"
    "indentation_sensitive = 1;\n"
    "wrap_blocks_in_braces = 0;\n"
    "\n"
    "conf:api = record;\n"
    "conf:api:style = free-form;\n"
    "conf:api:sigil = \"@@\";\n"
    "conf:define:YYGETCOND:naked = 0;\n"
    "conf:define:YYSETCOND:naked = 0;\n"
    "conf:define:YYSETCOND@cond = \"@@\";\n"
    "conf:define:YYGETSTATE:naked = 0;\n"
    "conf:define:YYSETSTATE:naked = 0;\n"
    "conf:define:YYSETSTATE@state = \"@@\";\n"
    "conf:define:YYFILL@len = \"@@\";\n"
    "conf:define:YYFILL:naked = 0;\n"
    "conf:define:YYFN = [\"<undefined-function-name>;<undefined-function-type>\"];\n"
    "conf:yyfn:sep = \";\";\n"
    "conf:variable:yycond = \"yycond\";\n"
    "conf:variable:yyctable = \"yyctable\";\n"
    "conf:variable:yyaccept = \"yyaccept\";\n"
    "conf:variable:yytarget = \"yytarget\";\n"
    "conf:variable:yystate = \"yystate\";\n"
    "conf:variable:yynmatch = \"\"; // no array for `yypmatch` in Haskell => no need for `yynmatch`\n"
    "conf:variable:yypmatch = \"yypmatch\";\n"
    "conf:variable:yyrecord = \"yyrecord\";\n"
    "conf:variable:yych = \"yych\";\n"
    "conf:variable:yych:conversion = 0;\n"
    "conf:variable:yych:literals = hex;\n"
    "conf:variable:yych:emit = (code_model.recursive_functions ? 0 : 1);\n"
    "conf:variable:yybm = \"yybm\";\n"
    "conf:variable:yybm:hex = 0;\n"
    "conf:variable:yyfill = \"yyfill\";\n"
    "conf:variable:yystable = \"\"; // deprecated\n"
    "conf:header = \"\";\n"
    "conf:eof = -1;\n"
    "conf:sentinel = -1;\n"
    "conf:yyfill:enable = 1;\n"
    "conf:yyfill:parameter = 1;\n"
    "conf:yyfill:check = 1;\n"
    "conf:tags = 0;\n"
    "conf:leftmost-captures = 0;\n"
    "conf:posix-captures = 0;\n"
    "conf:tags:prefix = \"_yyt\";\n"
    "conf:invert-captures = 0;\n"
    "conf:cond:abort = 1;\n"
    "conf:cond:prefix = \"yyc_\";\n"
    "conf:cond:enumprefix = \"YYC_\";\n"
    "conf:cond:divider@cond = \"@@\";\n"
    "conf:cond:goto@cond = \"@@\";\n"
    "conf:state:abort = 1;\n"
    "conf:state:nextlabel = 0;\n"
    "conf:bit-vectors = 0;\n"
    "conf:debug-output = 0;\n"
    "conf:computed-gotos = 0;\n"
    "conf:computed-gotos:threshold = 9;\n"
    "conf:nested-ifs = 0;\n"
    "conf:case-insensitive = 0;\n"
    "conf:case-inverted = 0;\n"
    "conf:case-ranges = 0;\n"
    "conf:unsafe = 0;\n"
    "conf:monadic = 0;\n"
    "conf:encoding:ebcdic = 0;\n"
    "conf:encoding:utf32 = 0;\n"
    "conf:encoding:ucs2 = 0;\n"
    "conf:encoding:utf16 = 0;\n"
    "conf:encoding:utf8 = 0;\n"
    "conf:encoding-policy = ignore;\n"
    "conf:empty-class = match-empty;\n"
    "conf:indent:string = \"    \";\n"
    "conf:indent:top = 0;\n"
    "conf:label:prefix = \"yy\";\n"
    "conf:label:yyfill = \"yyFillLabel\";\n"
    "conf:label:yyloop = \"\";\n"
    "conf:label:yyNext = \"yyNext\";\n"
    "conf:label:start = 0;\n"
    "\n"
    "conf:define:YYBACKUP = \"yybackup\";\n"
    "conf:define:YYBACKUPCTX = \"yybackupctx\";\n"
    "conf:define:YYCONDTYPE = \"YYCONDTYPE\";\n"
    "conf:define:YYCOPYMTAG = \"yycopymtag\";\n"
    "conf:define:YYCOPYSTAG = \"yycopystag\";\n"
    "conf:define:YYCTYPE = \"YYCTYPE\";\n"
    "conf:define:YYCTXMARKER = \"yyctxmarker\";\n"
    "conf:define:YYCURSOR = \"yycursor\";\n"
    "conf:define:YYDEBUG = \"yydebug\";\n"
    "conf:define:YYFILL = \"yyfill\";\n"
    "conf:define:YYGETACCEPT = \"yygetaccept\";\n"
    "conf:define:YYGETCOND = \"yygetcond\";\n"
    "conf:define:YYGETSTATE = \"yygetstate\";\n"
    "conf:define:YYLESSTHAN = \"yylessthan\";\n"
    "conf:define:YYLIMIT = \"yylimit\";\n"
    "conf:define:YYMARKER = \"YYMARKER\";\n"
    "conf:define:YYMAXFILL = \"yymaxfill\";\n"
    "conf:define:YYMAXNMATCH = \"yymaxnmatch\";\n"
    "conf:define:YYMTAGN = \"yymtagn\";\n"
    "conf:define:YYMTAGP = \"yymtagp\";\n"
    "conf:define:YYPEEK = (api.record ? \"index\" : \"yypeek\");\n"
    "conf:define:YYRESTORE = \"yyrestore\";\n"
    "conf:define:YYRESTORECTX = \"yyrestorectx\";\n"
    "conf:define:YYRESTORETAG = \"yyrestoretag\";\n"
    "conf:define:YYSETACCEPT = \"yysetaccept\";\n"
    "conf:define:YYSETCOND = \"yysetcond\";\n"
    "conf:define:YYSETSTATE = \"yysetstate\";\n"
    "conf:define:YYSHIFT = \"yyshift\";\n"
    "conf:define:YYSHIFTSTAG = \"yyshiftstag\";\n"
    "conf:define:YYSHIFTMTAG = \"yyshiftmtag\";\n"
    "conf:define:YYSKIP = \"yyskip\";\n"
    "conf:define:YYSTAGN = \"yystagn\";\n"
    "conf:define:YYSTAGP = \"yystagp\";\n"
    "conf:tags:expression = sigil;\n"
    "conf:cond:divider = \"\";\n"
    "conf:cond:goto = \"\";\n"
    "\n"
    "code:var_local = topindent \"let \" name \" = \" init \" in\" nl;\n"
    "code:var_global = topindent \"let \" name \" = \" init nl;\n"
    "\n"
    "code:const_local = topindent \"let \" name \" = \" init \" in\" nl;\n"
    "code:const_global = topindent name \" = \" init nl;\n"
    "\n"
    "// code:array_local\n"
    "// code:array_global\n"
    "\n"
    "// `code:array_elem` is used to generate operations on POSIX `yypmatch` array.\n"
    "// Override it to generate an identifier instead, as mutable arrays are non-idiomatic in Haskell.\n"
    "code:array_elem = array index;\n"
    "\n"
    "code:type_int = \"int\";\n"
    "code:type_uint = \"uint\";\n"
    "code:type_cond_enum = (storable_state? \"int\" : \"uint\");\n"
    "// code:type_yybm\n"
    "// code:type_yytarget\n"
    "\n"
    "// code:assign\n"
    "\n"
    "code:if_then_else =\n"
    "    [branch{0}: topindent (many ? \"if \" cond \" then\" : \"when (\" cond \") $\") (monadic ? \" do\") nl\n"
    "        indent [stmt: stmt] dedent]\n"
    "    [branch{1:-1}: topindent \"else\" (have_cond? \" if \" cond \" then\") (monadic ? \" do\") nl\n"
    "        indent [stmt: stmt] dedent];\n"
    "\n"
    "code:if_then_else_oneline =\n"
    "    [branch{0}: topindent (many ? \"if \" cond \" then \" : \"when (\" cond \") $ \") [stmt: stmt] nl]\n"
    "    [branch{1:-1}: topindent \"else \" (have_cond? \"if \" cond \" then \") [stmt: stmt] nl];\n"
    "\n"
    "code:switch =\n"
    "    topindent \"case \" expr \" of\" nl\n"
    "        indent [case: case] dedent;\n"
    "\n"
    "code:switch_cases = topindent \"_c | \"\n"
    "    [case{0:-2}: case \" || \"]\n"
    "    [case{-1}:   case \" ->\" (monadic ? \" do\") nl\n"
    "        indent [stmt: stmt] dedent\n"
    "    ];\n"
    "\n"
    "code:switch_case_range = (many\n"
    "    ? [val{0}: val] \" <= _c && _c <= \" [val{-1}: val]\n"
    "    : [val{0}: val] \" == _c\");\n"
    "\n"
    "code:switch_case_default = \"True\";\n"
    "\n"
    "code:enum =\n"
    "    \"data \" name \" = \"\n"
    "        [elem{0:-2}: elem \" | \"]\n"
    "        [elem{-1}: elem] \" deriving (Eq, Show)\"\n"
    "    nl;\n"
    "\n"
    "code:enum_elem = name;\n"
    "\n"
    "code:fndef =\n"
    "    name \" :: \" [arg: argtype \" -> \"] type nl\n"
    "    name [arg: \" \" argname] \" =\" (monadic ? \" do\") nl\n"
    "        indent [stmt: stmt] dedent;\n"
    "\n"
    "code:fncall =\n"
    "    topindent (have_retval ? \"let \" retval \" = \")\n"
    "        name (have_args ? [arg: \" \" arg] : \" ()\") nl;\n"
    "\n"
    "code:tailcall = topindent name (have_args ? [arg: \" \" arg] : \" ()\") nl;\n"
    "\n"
    "code:recursive_functions = [fn: fndef nl];\n"
    "\n"
    "code:fingerprint =\n"
    "    \"-- Generated by re2c\" (have_version? \" \" version) (have_date? \" on \" date) nl\n"
    "    (api.record ? \"{-# LANGUAGE RecordWildCards #-}\" nl);\n"
    "\n"
    "code:line_info = \"#\" line \" \\\"\" file \"\\\"\" nl;\n"
    "\n"
    "code:abort = topindent \"error \\\"internal lexer error\\\"\" nl;\n"
    "\n"
    "code:yydebug = topindent debug nl;\n"
    "\n"
    "code:yypeek =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? char \" <- return $ \" peek \" _str _cur\"\n"
    "            : \"let \" char \" = \" peek \" _str _cur in\")\n"
    "        : (monadic\n"
    "            ? char \" <- \" peek\n"
    "            : \"let \" char \" = \" peek \" in\")\n"
    "    ) nl;\n"
    "\n"
    "code:yyskip =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"_cur <- return $ _cur + 1\"\n"
    "            : \"let __ = _cur + 1 in let _cur = __ in\")\n"
    "        : skip\n"
    "    ) nl;\n"
    "\n"
    "code:yybackup =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let _mar = _cur\"\n"
    "            : \"let _mar = _cur in\")\n"
    "        : backup\n"
    "    ) nl;\n"
    "\n"
    "code:yybackupctx =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let _ctx = _cur\"\n"
    "            : \"let _ctx = _cur in\")\n"
    "        : backupctx\n"
    "    ) nl;\n"
    "\n"
    "code:yyrestore =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let _cur = _mar\"\n"
    "            : \"let _cur = _mar in\")\n"
    "        : restore\n"
    "    ) nl;\n"
    "\n"
    "code:yyrestorectx =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let _cur = _ctx\"\n"
    "            : \"let _cur = _ctx in\")\n"
    "        : restorectx\n"
    "    ) nl;\n"
    "\n"
    "code:yyrestoretag =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let _cur = \" tag\n"
    "            : \"let _cur = \" tag \" in\")\n"
    "        : restoretag\n"
    "    ) nl;\n"
    "\n"
    "code:yyshift =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"_cur <- return $ _cur - \" offset\n"
    "            : \"let __ = _cur - \" offset \" in let _cur = __ in\")\n"
    "        : shift\n"
    "    ) nl;\n"
    "\n"
    "code:yyshiftstag =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? tag \" <- return $ if \" tag \" == (-1) then (-1) else \" tag \" - \" offset\n"
    "            :         \"let __ = if \" tag \" == (-1) then (-1) else \" tag \" - \" offset\n"
    "                \" in let \" tag \" = __ in\")\n"
    "        : shiftstag\n"
    "    ) nl;\n"
    "\n"
    "code:yyshiftmtag = topindent shiftmtag nl;\n"
    "\n"
    "code:yystagp =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let \" tag \" = _cur\"\n"
    "            : \"let \" tag \" = _cur in\")\n"
    "        : stagp\n"
    "    ) nl;\n"
    "\n"
    "code:yymtagp = topindent mtagp nl;\n"
    "\n"
    "code:yystagn =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let \" tag \" = (-1)\"\n"
    "            : \"let \" tag \" = (-1) in\")\n"
    "        : stagn\n"
    "    ) nl;\n"
    "\n"
    "code:yymtagn = topindent mtagn nl;\n"
    "\n"
    "code:yycopystag =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let \" lhs \" = \" rhs\n"
    "            : \"let \" lhs \" = \" rhs \" in\")\n"
    "        : copystag\n"
    "    ) nl;\n"
    "\n"
    "code:yycopymtag =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let \" lhs \" = \" rhs\n"
    "            : \"let \" lhs \" = \" rhs \" in\")\n"
    "        : copymtag\n"
    "    ) nl;\n"
    "\n"
    "code:yygetaccept = (api.record ? \"_accept\" : getaccept);\n"
    "\n"
    "code:yysetaccept =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let _accept = \" val\n"
    "            : \"let _accept = \" val \" in\")\n"
    "        : setaccept\n"
    "    ) nl;\n"
    "\n"
    "code:yygetcond = (api.record ? \"_cond\" : getcond);\n"
    "\n"
    "code:yysetcond =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let _cond = \" cond\n"
    "            : \"let _cond = \" cond \" in\")\n"
    "        : setcond\n"
    "    ) nl;\n"
    "\n"
    "code:yygetstate = (api.record ? \"_state\" : getstate);\n"
    "\n"
    "code:yysetstate =\n"
    "    topindent (api.record\n"
    "        ? (monadic\n"
    "            ? \"let _state = \" state\n"
    "            : \"let _state = \" state \" in\")\n"
    "        : setstate\n"
    "    ) nl;\n"
    "\n"
    "code:yylessthan =\n"
    "    (api.record\n"
    "        ? \"_cur >= _lim\" // YYFILL check can only be used with EOF rule $\n"
    "        : lessthan);\n"
    ;
