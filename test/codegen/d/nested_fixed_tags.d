/* Generated by re2c */
// re2d $INPUT -o $OUTPUT -i
module main;



private long lex_tags(const(char)* str) {
    const(char)* cur = str, mar, x, y;
    const(char)* yyt1;

    
{
	char yych;
	mar = cur;
	yych = *cur;
	switch (yych) {
		case 'b': goto yy2;
		default:
			yyt1 = null;
			goto yy1;
	}
yy1:
	y = yyt1;
	x = yyt1;
	yyt1 = null;
	if (x != yyt1) x += -1;
	{ return x == null ? -1 : (y - x); }
yy2:
	++cur;
	yych = *cur;
	switch (yych) {
		case 'a': goto yy4;
		default: goto yy3;
	}
yy3:
	cur = mar;
	yyt1 = null;
	goto yy1;
yy4:
	++cur;
	yyt1 = cur;
	goto yy1;
}

}

enum YYMAXNMATCH = 3;


private long lex_captures(const(char)* str) {
    const(char)* cur = str;
    uint yynmatch;
    const(char)*[2*YYMAXNMATCH] yypmatch; 
    const(char)* yyt1;
const(char)* yyt2;

    
{
	char yych;
	yych = *cur;
	switch (yych) {
		case 'a':
			yyt1 = cur;
			goto yy7;
		default:
			yyt1 = cur;
			yyt2 = null;
			goto yy6;
	}
yy6:
	yynmatch = 3;
	yypmatch[0] = yyt1;
	yypmatch[3] = yyt2;
	yypmatch[5] = yyt2;
	yypmatch[1] = cur;
	yypmatch[2] = yyt2;
	yyt2 = null;
	if (yypmatch[2] != yyt2) yypmatch[2] += -1;
	yypmatch[4] = yypmatch[2];
	{ return yypmatch[4] == null ? -1 : yypmatch[4] - str; }
yy7:
	++cur;
	yyt2 = cur;
	goto yy6;
}

}

void main() {
    assert(lex_tags("") == -1);
    assert(lex_tags("ba") == 1);
    assert(lex_captures("") == -1);
    assert(lex_captures("a") == 0);
}
codegen/d/nested_fixed_tags.re:21:25: warning: rule matches empty string [-Wmatch-empty-string]
codegen/d/nested_fixed_tags.re:34:17: warning: rule matches empty string [-Wmatch-empty-string]
