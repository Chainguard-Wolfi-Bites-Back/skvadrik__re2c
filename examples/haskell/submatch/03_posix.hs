-- Generated by re2c
#1 "haskell/submatch/03_posix.re"
-- re2hs $INPUT -o $OUTPUT
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE RecordWildCards #-}

import Control.Monad (when)
import Data.ByteString as BS
import Data.Word

none :: Int
none = -1

data State = State {
    str :: !BS.ByteString,
    cur :: !Int,
    mar :: !Int,
    
#21 "haskell/submatch/03_posix.hs"

yyt1 :: !Int,
yyt2 :: !Int,
yyt3 :: !Int,
yyt4 :: !Int,
yyt5 :: !Int,
#17 "haskell/submatch/03_posix.re"

    -- use record fields instead of canonical POSIX `yypmatch` array,
    -- as mutable arrays are non-idiomatic in Haskell
    yypmatch0 :: !Int,
    yypmatch1 :: !Int,
    yypmatch2 :: !Int,
    yypmatch3 :: !Int,
    yypmatch4 :: !Int,
    yypmatch5 :: !Int,
    yypmatch6 :: !Int,
    yypmatch7 :: !Int
} deriving (Show)

data SemVer = SemVer {
    major :: !Int,
    minor :: !Int,
    patch :: !Int
} deriving (Show, Eq)

s2n :: BS.ByteString -> Int -> Int -> Int
s2n s i j = f i 0 where
    f k n = if k >= j then n else f (k + 1) (n * 10 + (fromIntegral (BS.index s k) - 48))


#53 "haskell/submatch/03_posix.hs"
yy0 :: State -> Maybe SemVer
yy0 !_s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{yyt1 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy3 _s
        _c | True ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy1 _s

yy1 :: State -> Maybe SemVer
yy1 !_s =
    yy2 _s

yy2 :: State -> Maybe SemVer
yy2 !_s =
#65 "haskell/submatch/03_posix.re"
    Nothing
#74 "haskell/submatch/03_posix.hs"

yy3 :: State -> Maybe SemVer
yy3 !_s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x2E == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy4 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy6 _s
        _c | True ->
            yy2 _s

yy4 :: State -> Maybe SemVer
yy4 !_s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{yyt2 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | True ->
            yy5 _s

yy5 :: State -> Maybe SemVer
yy5 !_s =
    let _t = _s{cur = _s.mar} in let _s = _t in
    yy2 _s

yy6 :: State -> Maybe SemVer
yy6 !_s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x2E == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy4 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy6 _s
        _c | True ->
            yy5 _s

yy7 :: State -> Maybe SemVer
yy7 !_s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x00 == _c ->
            let _t = _s{yyt3 = _s.cur} in let _s = _t in
            let _t = _s{yyt4 = none} in let _s = _t in
            let _t = _s{yyt5 = none} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy8 _s
        _c | 0x2E == _c ->
            let _t = _s{yyt3 = _s.cur} in let _s = _t in
            let _t = _s{yyt5 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy9 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | True ->
            yy5 _s

yy8 :: State -> Maybe SemVer
yy8 !_s =
    let _t = _s{yypmatch2 = _s.yyt1} in let _s = _t in
    let _t = _s{yypmatch4 = _s.yyt2} in let _s = _t in
    let _t = _s{yypmatch5 = _s.yyt3} in let _s = _t in
    let _t = _s{yypmatch6 = _s.yyt5} in let _s = _t in
    let _t = _s{yypmatch7 = _s.yyt4} in let _s = _t in
    let _t = _s{yypmatch0 = _s.yyt1} in let _s = _t in
    let _t = _s{yypmatch1 = _s.cur} in let _s = _t in
    let _t = _s{yypmatch3 = _s.yyt2} in let _s = _t in
    let _t = if _s.yypmatch3 == none then _s else _s{yypmatch3 = _s.yypmatch3 + (-1)} in let _s = _t in
#56 "haskell/submatch/03_posix.re"
    -- Even `yypmatch` values are for opening parentheses, odd values
    -- are for closing parentheses, the first group is the whole match.
    Just SemVer {
        major = s2n _s.str _s.yypmatch2 _s.yypmatch3,
        minor = s2n _s.str _s.yypmatch4 _s.yypmatch5,
        patch = if _s.yypmatch6 == none then 0 else s2n _s.str (_s.yypmatch6 + 1) _s.yypmatch7
    }
#159 "haskell/submatch/03_posix.hs"

yy9 :: State -> Maybe SemVer
yy9 !_s =
    let yych = BS.index _s.str _s.cur in
    if yych <= 0x00 then yy5 _s
    else yy11 _s yych

yy10 :: State -> Maybe SemVer
yy10 !_s =
    let yych = BS.index _s.str _s.cur in
    yy11 _s yych

yy11 :: State -> Word8 -> Maybe SemVer
yy11 !_s yych =
    case yych of
        _c | 0x00 == _c ->
            let _t = _s{yyt4 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy8 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy10 _s
        _c | True ->
            yy5 _s

parse :: State -> Maybe SemVer
parse !_s =
    yy0 _s

#66 "haskell/submatch/03_posix.re"


test :: BS.ByteString -> Maybe SemVer -> IO ()
test str expect = do
    let s = State {
        str = str,
        cur = 0,
        mar = 0,
        
#199 "haskell/submatch/03_posix.hs"

yyt1 = none,
yyt2 = none,
yyt3 = none,
yyt4 = none,
yyt5 = none,
#74 "haskell/submatch/03_posix.re"

        yypmatch0 = none,
        yypmatch1 = none,
        yypmatch2 = none,
        yypmatch3 = none,
        yypmatch4 = none,
        yypmatch5 = none,
        yypmatch6 = none,
        yypmatch7 = none
    }
    when (parse s /= expect) $ error "failed!"

main :: IO ()
main = do
    test "23.34\0" (Just SemVer {major = 23, minor = 34, patch = 0})
    test "1.2.99999\0" (Just SemVer {major = 1, minor = 2, patch = 99999})
    test "1.a\0" Nothing
