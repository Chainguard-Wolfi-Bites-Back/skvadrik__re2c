-- Generated by re2c
#1 "haskell/submatch/01_stags_fill.re"
-- re2hs $INPUT -o $OUTPUT
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad
import Data.ByteString as BS
import GHC.IO.Handle
import System.Directory
import System.IO

chunk_size :: Int
chunk_size = 4096

data State = State {
    file :: !Handle,
    buf :: !BS.ByteString,
    cur :: !Int,
    mar :: !Int,
    lim :: !Int,
    tok :: !Int,
    eof :: !Bool,
    
#26 "haskell/submatch/01_stags_fill.hs"

yyt1 :: !Int,
yyt2 :: !Int,
yyt3 :: !Int,
yyt4 :: !Int,
#22 "haskell/submatch/01_stags_fill.re"

    t1 :: !Int,
    t2 :: !Int,
    t3 :: !Int,
    t4 :: !Int,
    t5 :: !Int
} deriving (Show)

data SemVer = SemVer {
    major :: !Int,
    minor :: !Int,
    patch :: !Int
} deriving (Show, Eq)

none :: Int
none = -1

s2n :: BS.ByteString -> Int -> Int -> Int
s2n s i j = f i 0 where
    f k n = if k >= j then n else f (k + 1) (n * 10 + (fromIntegral (BS.index s k) - 48))


#55 "haskell/submatch/01_stags_fill.hs"
yy0 :: State -> [SemVer] -> IO [SemVer]
yy0 !_st !_vs = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 -> do
            _st <- return _st{yyt1 = _st.cur}
            _st <- return _st{cur = _st.cur + 1}
            yy3 _st _vs
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy0 _st _vs
                else yy11 _st _vs
            else do
                _st <- return _st{cur = _st.cur + 1}
                yy1 _st _vs

yy1 :: State -> [SemVer] -> IO [SemVer]
yy1 !_st !_vs = do
    yy2 _st _vs

yy2 :: State -> [SemVer] -> IO [SemVer]
yy2 !_st !_vs = do
#71 "haskell/submatch/01_stags_fill.re"
    error "lexer failed"
#81 "haskell/submatch/01_stags_fill.hs"

yy3 :: State -> [SemVer] -> IO [SemVer]
yy3 !_st !_vs = do
    _st <- return _st{mar = _st.cur}
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x2E == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy4 _st _vs
        _c | 0x30 <= _c && _c <= 0x39 -> do
            _st <- return _st{cur = _st.cur + 1}
            yy6 _st _vs
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy3 _st _vs
                else yy2 _st _vs
            else do
                yy2 _st _vs

yy4 :: State -> [SemVer] -> IO [SemVer]
yy4 !_st !_vs = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 -> do
            _st <- return _st{yyt2 = _st.cur}
            _st <- return _st{cur = _st.cur + 1}
            yy7 _st _vs
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy4 _st _vs
                else yy5 _st _vs
            else do
                yy5 _st _vs

yy5 :: State -> [SemVer] -> IO [SemVer]
yy5 !_st !_vs = do
    _st <- return _st{cur = _st.mar}
    yy2 _st _vs

yy6 :: State -> [SemVer] -> IO [SemVer]
yy6 !_st !_vs = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x2E == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy4 _st _vs
        _c | 0x30 <= _c && _c <= 0x39 -> do
            _st <- return _st{cur = _st.cur + 1}
            yy6 _st _vs
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy6 _st _vs
                else yy5 _st _vs
            else do
                yy5 _st _vs

yy7 :: State -> [SemVer] -> IO [SemVer]
yy7 !_st !_vs = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x0A == _c -> do
            _st <- return _st{yyt3 = _st.cur}
            _st <- return _st{yyt4 = none}
            _st <- return _st{cur = _st.cur + 1}
            yy8 _st _vs
        _c | 0x2E == _c -> do
            _st <- return _st{yyt3 = _st.cur}
            _st <- return _st{cur = _st.cur + 1}
            yy9 _st _vs
        _c | 0x30 <= _c && _c <= 0x39 -> do
            _st <- return _st{cur = _st.cur + 1}
            yy7 _st _vs
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy7 _st _vs
                else yy5 _st _vs
            else do
                yy5 _st _vs

yy8 :: State -> [SemVer] -> IO [SemVer]
yy8 !_st !_vs = do
    _st <- return _st{t1 = _st.yyt1}
    _st <- return _st{t3 = _st.yyt2}
    _st <- return _st{t4 = _st.yyt3}
    _st <- return _st{t5 = _st.yyt4}
    _st <- return _st{t2 = _st.yyt2}
    _st <- return $ if _st.t2 == none then _st else _st{t2 = _st.t2 + (-1)}
#62 "haskell/submatch/01_stags_fill.re"
    let v = SemVer {
        major = s2n _st.buf _st.t1 _st.t2,
        minor = s2n _st.buf _st.t3 _st.t4,
        patch = if _st.t5 == none then 0 else s2n _st.buf _st.t5 (_st.cur - 1)
    }
    lexer _st (v: _vs)
#180 "haskell/submatch/01_stags_fill.hs"

yy9 :: State -> [SemVer] -> IO [SemVer]
yy9 !_st !_vs = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 -> do
            _st <- return _st{yyt4 = _st.cur}
            _st <- return _st{cur = _st.cur + 1}
            yy10 _st _vs
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy9 _st _vs
                else yy5 _st _vs
            else do
                yy5 _st _vs

yy10 :: State -> [SemVer] -> IO [SemVer]
yy10 !_st !_vs = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x0A == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy8 _st _vs
        _c | 0x30 <= _c && _c <= 0x39 -> do
            _st <- return _st{cur = _st.cur + 1}
            yy10 _st _vs
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy10 _st _vs
                else yy5 _st _vs
            else do
                yy5 _st _vs

yy11 :: State -> [SemVer] -> IO [SemVer]
yy11 !_st !_vs = do
#70 "haskell/submatch/01_stags_fill.re"
    return _vs
#220 "haskell/submatch/01_stags_fill.hs"

lexer :: State -> [SemVer] -> IO [SemVer]
lexer !_st !_vs = do
    yy0 _st _vs

#72 "haskell/submatch/01_stags_fill.re"


fill :: State -> IO (State, Bool)
fill st = do
    case st.eof of
        True -> return (st, False)
        False -> do
            -- Discard everything up to the current token, cut off terminating null,
            -- read new chunk from file and reappend terminating null at the end.
            chunk <- BS.hGet st.file chunk_size
            let st' = st{
                buf = BS.concat [(BS.init . BS.drop st.tok) st.buf, chunk, "\0"],
                cur = st.cur - st.tok,
                mar = st.mar - st.tok,
                lim = st.lim - st.tok + BS.length chunk, -- exclude terminating null
                tok = 0,
                eof = BS.null chunk -- end of file?
            }
            return (st', True)

main :: IO ()
main = do
    let fname = "input"

    -- Prepare input file.
    BS.writeFile fname $ BS.concat ["1.22.333\n" | _ <- [1..chunk_size]]
    let expect = [SemVer {major = 1, minor = 22, patch = 333} | _ <- [1..chunk_size]]

    -- Run lexer on the prepared file.
    fh <- openFile fname ReadMode
    let st = State {
        file = fh,
        buf = BS.singleton 0,
        cur = 0,
        mar = 0,
        tok = 0,
        lim = 0,
        eof = False,
        
#266 "haskell/submatch/01_stags_fill.hs"

yyt1 = none,
yyt2 = none,
yyt3 = none,
yyt4 = none,
#110 "haskell/submatch/01_stags_fill.re"

        t1 = none,
        t2 = none,
        t3 = none,
        t4 = none,
        t5 = none
    }
    result <- lexer st []
    hClose fh

    -- Cleanup.
    removeFile fname

    -- Check result.
    when (result /= expect) $ error $ "expected " ++ show expect ++ ", got " ++ show result
    return ()
