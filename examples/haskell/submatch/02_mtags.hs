-- Generated by re2c
#1 "haskell/submatch/02_mtags.re"
-- re2hs $INPUT -o $OUTPUT
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

import Control.Monad (when)
import qualified Data.ByteString as BS

data State = State {
    _str :: !BS.ByteString,
    _cur :: !Int,
    _mar :: !Int,
    
#17 "haskell/submatch/02_mtags.hs"

_t1 :: !Int,
_t2 :: !Int,
#13 "haskell/submatch/02_mtags.re"

    _1 :: !Int,
    _2 :: !Int,
    
#26 "haskell/submatch/02_mtags.hs"

_tm3 :: ![Int],
_tm4 :: ![Int],
#16 "haskell/submatch/02_mtags.re"

    _3 :: ![Int],
    _4 :: ![Int]
} deriving (Show)

none :: Int
none = -1

s2n :: BS.ByteString -> Int -> Int -> Int
s2n s i j = f i 0 where
    f k n = if k >= j then n else f (k + 1) (n * 10 + (fromIntegral (BS.index s k) - 48))


#44 "haskell/submatch/02_mtags.hs"
yy0 :: State -> Maybe [Int]
yy0 State{..} =
    let yych = BS.index _str _cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t1 = _cur in
            let cur = _cur + 1 in let _cur = cur in
            yy3 State{..}
        _c | True ->
            let cur = _cur + 1 in let _cur = cur in
            yy1 State{..}

yy1 :: State -> Maybe [Int]
yy1 State{..} =
    yy2 State{..}

yy2 :: State -> Maybe [Int]
yy2 State{..} =
#50 "haskell/submatch/02_mtags.re"
    Nothing
#65 "haskell/submatch/02_mtags.hs"

yy3 :: State -> Maybe [Int]
yy3 State{..} =
    let _mar = _cur in
    let yych = BS.index _str _cur in
    case yych of
        _c | 0x00 == _c ->
            
            
            let _t2 = _cur in
            let cur = _cur + 1 in let _cur = cur in
            yy4 State{..}
        _c | 0x2E == _c ->
            let _t2 = _cur in
            let cur = _cur + 1 in let _cur = cur in
            yy5 State{..}
        _c | 0x30 <= _c && _c <= 0x39 ->
            let cur = _cur + 1 in let _cur = cur in
            yy7 State{..}
        _c | True ->
            yy2 State{..}

yy4 :: State -> Maybe [Int]
yy4 State{..} =
    let _1 = _t1 in
    let _2 = _t2 in
    let _3 = _tm3 in
    let _4 = _tm4 in
#47 "haskell/submatch/02_mtags.re"
    Just $ (s2n _str _1 _2) : (reverse $ zipWith (\i j -> s2n _str i j) _3 _4)
#96 "haskell/submatch/02_mtags.hs"

yy5 :: State -> Maybe [Int]
yy5 State{..} =
    let yych = BS.index _str _cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let tag = _cur : _tm3 in let _tm3 = tag in
            let cur = _cur + 1 in let _cur = cur in
            yy8 State{..}
        _c | True ->
            yy6 State{..}

yy6 :: State -> Maybe [Int]
yy6 State{..} =
    let _cur = _mar in
    yy2 State{..}

yy7 :: State -> Maybe [Int]
yy7 State{..} =
    let yych = BS.index _str _cur in
    case yych of
        _c | 0x00 == _c ->
            
            
            let _t2 = _cur in
            let cur = _cur + 1 in let _cur = cur in
            yy4 State{..}
        _c | 0x2E == _c ->
            let _t2 = _cur in
            let cur = _cur + 1 in let _cur = cur in
            yy5 State{..}
        _c | 0x30 <= _c && _c <= 0x39 ->
            let cur = _cur + 1 in let _cur = cur in
            yy7 State{..}
        _c | True ->
            yy6 State{..}

yy8 :: State -> Maybe [Int]
yy8 State{..} =
    let yych = BS.index _str _cur in
    case yych of
        _c | 0x00 == _c ->
            let tag = _cur : _tm4 in let _tm4 = tag in
            let cur = _cur + 1 in let _cur = cur in
            yy4 State{..}
        _c | 0x2E == _c ->
            let tag = _cur : _tm4 in let _tm4 = tag in
            let cur = _cur + 1 in let _cur = cur in
            yy5 State{..}
        _c | 0x30 <= _c && _c <= 0x39 ->
            let cur = _cur + 1 in let _cur = cur in
            yy8 State{..}
        _c | True ->
            yy6 State{..}

parse :: State -> Maybe [Int]
parse State{..} =
    yy0 State{..}

#51 "haskell/submatch/02_mtags.re"


test :: BS.ByteString -> Maybe [Int] -> IO ()
test str expect = do
    let st = State {
        _str = str,
        _cur = 0,
        _mar = 0,
        
#166 "haskell/submatch/02_mtags.hs"

_t1 = none,
_t2 = none,
#59 "haskell/submatch/02_mtags.re"

        _1 = none,
        _2 = none,
        
#175 "haskell/submatch/02_mtags.hs"

_tm3 = [],
_tm4 = [],
#62 "haskell/submatch/02_mtags.re"

        _3 = [],
        _4 = []
    }
    when (parse st /= expect) $ error "failed!"

main :: IO ()
main = do
    test "1\0" (Just [1])
    test "1.2.3.4.5.6.7\0" (Just [1, 2, 3, 4, 5, 6, 7])
    test "1.2.\0" Nothing
