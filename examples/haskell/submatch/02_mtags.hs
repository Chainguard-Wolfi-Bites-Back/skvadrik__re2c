-- Generated by re2c
#1 "haskell/submatch/02_mtags.re"
-- re2hs $INPUT -o $OUTPUT
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE RecordWildCards #-}

import Control.Monad (when)
import Data.ByteString as BS

data State = State {
    str :: !BS.ByteString,
    cur :: !Int,
    mar :: !Int,
    
#17 "haskell/submatch/02_mtags.hs"

yyt1 :: !Int,
yyt2 :: !Int,
#13 "haskell/submatch/02_mtags.re"

    t1 :: !Int,
    t2 :: !Int,
    
#26 "haskell/submatch/02_mtags.hs"

yytm3 :: ![Int],
yytm4 :: ![Int],
#16 "haskell/submatch/02_mtags.re"

    t3 :: ![Int],
    t4 :: ![Int]
} deriving (Show)

none :: Int
none = -1

s2n :: BS.ByteString -> Int -> Int -> Int
s2n s i j = f i 0 where
    f k n = if k >= j then n else f (k + 1) (n * 10 + (fromIntegral (BS.index s k) - 48))


#44 "haskell/submatch/02_mtags.hs"
yy0 :: State -> Maybe [Int]
yy0 !_s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{yyt1 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy3 _s
        _c | True ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy1 _s

yy1 :: State -> Maybe [Int]
yy1 !_s =
    yy2 _s

yy2 :: State -> Maybe [Int]
yy2 !_s =
#51 "haskell/submatch/02_mtags.re"
    Nothing
#65 "haskell/submatch/02_mtags.hs"

yy3 :: State -> Maybe [Int]
yy3 !_s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x00 == _c ->
            
            
            let _t = _s{yyt2 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy4 _s
        _c | 0x2E == _c ->
            let _t = _s{yyt2 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy5 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | True ->
            yy2 _s

yy4 :: State -> Maybe [Int]
yy4 !_s =
    let _t = _s{t1 = _s.yyt1} in let _s = _t in
    let _t = _s{t2 = _s.yyt2} in let _s = _t in
    let _t = _s{t3 = _s.yytm3} in let _s = _t in
    let _t = _s{t4 = _s.yytm4} in let _s = _t in
#46 "haskell/submatch/02_mtags.re"
    let x = s2n _s.str _s.t1 _s.t2
        xs = Prelude.reverse $ Prelude.zipWith (\i j -> s2n _s.str i j) _s.t3 _s.t4
    in Just (x : xs)
#98 "haskell/submatch/02_mtags.hs"

yy5 :: State -> Maybe [Int]
yy5 !_s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{yytm3 = _s.cur : _s.yytm3} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy8 _s
        _c | True ->
            yy6 _s

yy6 :: State -> Maybe [Int]
yy6 !_s =
    let _t = _s{cur = _s.mar} in let _s = _t in
    yy2 _s

yy7 :: State -> Maybe [Int]
yy7 !_s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x00 == _c ->
            
            
            let _t = _s{yyt2 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy4 _s
        _c | 0x2E == _c ->
            let _t = _s{yyt2 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy5 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | True ->
            yy6 _s

yy8 :: State -> Maybe [Int]
yy8 !_s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x00 == _c ->
            let _t = _s{yytm4 = _s.cur : _s.yytm4} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy4 _s
        _c | 0x2E == _c ->
            let _t = _s{yytm4 = _s.cur : _s.yytm4} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy5 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy8 _s
        _c | True ->
            yy6 _s

parse :: State -> Maybe [Int]
parse !_s =
    yy0 _s

#52 "haskell/submatch/02_mtags.re"


test :: BS.ByteString -> Maybe [Int] -> IO ()
test str expect = do
    let s = State {
        str = str,
        cur = 0,
        mar = 0,
        
#168 "haskell/submatch/02_mtags.hs"

yyt1 = none,
yyt2 = none,
#60 "haskell/submatch/02_mtags.re"

        t1 = none,
        t2 = none,
        
#177 "haskell/submatch/02_mtags.hs"

yytm3 = [],
yytm4 = [],
#63 "haskell/submatch/02_mtags.re"

        t3 = [],
        t4 = []
    }
    when (parse s /= expect) $ error "failed!"

main :: IO ()
main = do
    test "1\0" (Just [1])
    test "1.2.3.4.5.6.7\0" (Just [1, 2, 3, 4, 5, 6, 7])
    test "1.2.\0" Nothing
