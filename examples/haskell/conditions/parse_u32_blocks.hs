-- Generated by re2c
-- re2hs $INPUT -o $OUTPUT -i
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}

import Control.Monad (when)
import Data.ByteString as BS

data State = State {
    str :: !BS.ByteString,
    cur :: !Int,
    mar :: !Int
} deriving (Show)

peek_digit :: BS.ByteString -> Int -> Int -> Int
peek_digit str idx offs = fromIntegral (BS.index str (idx - 1)) - offs




yy0 :: State -> Int -> Int
yy0 _s num =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 <= _c && _c <= 0x31 ->
            yy2 _s num
        _c | True ->
            yy1 _s num

yy1 :: State -> Int -> Int
yy1 _s num =
    num

yy2 :: State -> Int -> Int
yy2 _s num =
    parse_bin _s $ num * 2 + (peek_digit _s.str _s.cur 48)

parse_bin :: State -> Int -> Int
parse_bin _s num =
    yy0 _s num




yy3 :: State -> Int -> Int
yy3 _s num =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 <= _c && _c <= 0x37 ->
            yy5 _s num
        _c | True ->
            yy4 _s num

yy4 :: State -> Int -> Int
yy4 _s num =
    num

yy5 :: State -> Int -> Int
yy5 _s num =
    parse_oct _s $ num * 8 + (peek_digit _s.str _s.cur 48)

parse_oct :: State -> Int -> Int
parse_oct _s num =
    yy3 _s num




yy6 :: State -> Int -> Int
yy6 _s num =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            yy8 _s num
        _c | True ->
            yy7 _s num

yy7 :: State -> Int -> Int
yy7 _s num =
    num

yy8 :: State -> Int -> Int
yy8 _s num =
    parse_dec _s $ num * 10 + (peek_digit _s.str _s.cur 48)

parse_dec :: State -> Int -> Int
parse_dec _s num =
    yy6 _s num




yy9 :: State -> Int -> Int
yy9 _s num =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            yy11 _s num
        _c | 0x41 <= _c && _c <= 0x46 ->
            yy12 _s num
        _c | 0x61 <= _c && _c <= 0x66 ->
            yy13 _s num
        _c | True ->
            yy10 _s num

yy10 :: State -> Int -> Int
yy10 _s num =
    num

yy11 :: State -> Int -> Int
yy11 _s num =
    parse_hex _s $ num * 16 + (peek_digit _s.str _s.cur 48)

yy12 :: State -> Int -> Int
yy12 _s num =
    parse_hex _s $ num * 16 + (peek_digit _s.str _s.cur 55)

yy13 :: State -> Int -> Int
yy13 _s num =
    parse_hex _s $ num * 16 + (peek_digit _s.str _s.cur 87)

parse_hex :: State -> Int -> Int
parse_hex _s num =
    yy9 _s num




yy14 :: State -> Maybe Int
yy14 _s =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 == _c ->
            yy16 _s
        _c | 0x31 <= _c && _c <= 0x39 ->
            yy18 _s
        _c | True ->
            yy15 _s

yy15 :: State -> Maybe Int
yy15 _s =
    Nothing

yy16 :: State -> Maybe Int
yy16 _s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x42 == _c || 0x62 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy19 _s
        _c | 0x58 == _c || 0x78 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy21 _s
        _c | True ->
            yy17 _s

yy17 :: State -> Maybe Int
yy17 _s =
    Just $ parse_oct _s 0

yy18 :: State -> Maybe Int
yy18 _s =
    let _t = _s{cur = _s.cur + (-1)} in let _s = _t in
    Just $ parse_dec _s 0

yy19 :: State -> Maybe Int
yy19 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x31 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy22 _s
        _c | True ->
            yy20 _s

yy20 :: State -> Maybe Int
yy20 _s =
    let _t = _s{cur = _s.mar} in let _s = _t in
    yy17 _s

yy21 :: State -> Maybe Int
yy21 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 || 0x41 <= _c && _c <= 0x46 || 0x61 <= _c && _c <= 0x66 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy23 _s
        _c | True ->
            yy20 _s

yy22 :: State -> Maybe Int
yy22 _s =
    let _t = _s{cur = _s.cur + (-1)} in let _s = _t in
    Just $ parse_bin _s 0

yy23 :: State -> Maybe Int
yy23 _s =
    let _t = _s{cur = _s.cur + (-1)} in let _s = _t in
    Just $ parse_hex _s 0

parse :: State -> Maybe Int
parse _s =
    yy14 _s



test :: BS.ByteString -> Maybe Int -> IO ()
test str expect = do
    let s = State {str = str, cur = 0, mar = 0}
    when (parse s /= expect) $ error "failed!"

main :: IO ()
main = do
    test "\0" Nothing
    test "1234567890\0" (Just 1234567890)
    test "0b1101\0" (Just 13)
    test "0x7Fe\0" (Just 2046)
    test "0644\0" (Just 420)
    test "9223372036854775807\0" (Just 9223372036854775807)
