-- Generated by re2c
-- re2hs $INPUT -o $OUTPUT -ci
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}

import Control.Monad (when)
import Data.ByteString as BS

data YYCONDTYPE = YYC_init | YYC_bin | YYC_oct | YYC_dec | YYC_hex deriving (Eq, Show)


data State = State {
    str :: !BS.ByteString,
    cur :: !Int,
    mar :: !Int,
    cond :: !YYCONDTYPE
} deriving (Show)

peek_digit :: BS.ByteString -> Int -> Int -> Int
peek_digit str idx offs = fromIntegral (BS.index str (idx - 1)) - offs


yy1 :: State -> Int -> Maybe Int
yy1 _s _n =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 == _c ->
            yy3 _s _n
        _c | 0x31 <= _c && _c <= 0x39 ->
            yy5 _s _n
        _c | True ->
            yy2 _s _n

yy2 :: State -> Int -> Maybe Int
yy2 _s _n =
    Nothing

yy3 :: State -> Int -> Maybe Int
yy3 _s _n =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x42 == _c || 0x62 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy6 _s _n
        _c | 0x58 == _c || 0x78 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy8 _s _n
        _c | True ->
            yy4 _s _n

yy4 :: State -> Int -> Maybe Int
yy4 _s _n =
    let _t = _s{cond = YYC_oct} in let _s = _t in
    yyfnoct _s _n

yy5 :: State -> Int -> Maybe Int
yy5 _s _n =
    let _t = _s{cur = _s.cur + (-1)} in let _s = _t in
    let _t = _s{cond = YYC_dec} in let _s = _t in
    yyfndec _s _n

yy6 :: State -> Int -> Maybe Int
yy6 _s _n =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x31 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy9 _s _n
        _c | True ->
            yy7 _s _n

yy7 :: State -> Int -> Maybe Int
yy7 _s _n =
    let _t = _s{cur = _s.mar} in let _s = _t in
    yy4 _s _n

yy8 :: State -> Int -> Maybe Int
yy8 _s _n =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 || 0x41 <= _c && _c <= 0x46 || 0x61 <= _c && _c <= 0x66 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy10 _s _n
        _c | True ->
            yy7 _s _n

yy9 :: State -> Int -> Maybe Int
yy9 _s _n =
    let _t = _s{cur = _s.cur + (-1)} in let _s = _t in
    let _t = _s{cond = YYC_bin} in let _s = _t in
    yyfnbin _s _n

yy10 :: State -> Int -> Maybe Int
yy10 _s _n =
    let _t = _s{cur = _s.cur + (-1)} in let _s = _t in
    let _t = _s{cond = YYC_hex} in let _s = _t in
    yyfnhex _s _n

yyfninit :: State -> Int -> Maybe Int
yyfninit _s _n =
    yy1 _s _n

yy11 :: State -> Int -> Maybe Int
yy11 _s _n =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 <= _c && _c <= 0x31 ->
            yy13 _s _n
        _c | True ->
            yy12 _s _n

yy12 :: State -> Int -> Maybe Int
yy12 _s _n =
    Just _n

yy13 :: State -> Int -> Maybe Int
yy13 _s _n =
    yyfnbin _s $ _n * 2 + (peek_digit _s.str _s.cur 48)

yyfnbin :: State -> Int -> Maybe Int
yyfnbin _s _n =
    yy11 _s _n

yy14 :: State -> Int -> Maybe Int
yy14 _s _n =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 <= _c && _c <= 0x37 ->
            yy16 _s _n
        _c | True ->
            yy15 _s _n

yy15 :: State -> Int -> Maybe Int
yy15 _s _n =
    Just _n

yy16 :: State -> Int -> Maybe Int
yy16 _s _n =
    yyfnoct _s $ _n * 8 + (peek_digit _s.str _s.cur 48)

yyfnoct :: State -> Int -> Maybe Int
yyfnoct _s _n =
    yy14 _s _n

yy17 :: State -> Int -> Maybe Int
yy17 _s _n =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            yy19 _s _n
        _c | True ->
            yy18 _s _n

yy18 :: State -> Int -> Maybe Int
yy18 _s _n =
    Just _n

yy19 :: State -> Int -> Maybe Int
yy19 _s _n =
    yyfndec _s $ _n * 10 + (peek_digit _s.str _s.cur 48)

yyfndec :: State -> Int -> Maybe Int
yyfndec _s _n =
    yy17 _s _n

yy20 :: State -> Int -> Maybe Int
yy20 _s _n =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            yy22 _s _n
        _c | 0x41 <= _c && _c <= 0x46 ->
            yy23 _s _n
        _c | 0x61 <= _c && _c <= 0x66 ->
            yy24 _s _n
        _c | True ->
            yy21 _s _n

yy21 :: State -> Int -> Maybe Int
yy21 _s _n =
    Just _n

yy22 :: State -> Int -> Maybe Int
yy22 _s _n =
    yyfnhex _s $ _n * 16 + (peek_digit _s.str _s.cur 48)

yy23 :: State -> Int -> Maybe Int
yy23 _s _n =
    yyfnhex _s $ _n * 16 + (peek_digit _s.str _s.cur 55)

yy24 :: State -> Int -> Maybe Int
yy24 _s _n =
    yyfnhex _s $ _n * 16 + (peek_digit _s.str _s.cur 87)

yyfnhex :: State -> Int -> Maybe Int
yyfnhex _s _n =
    yy20 _s _n

yy0 :: State -> Int -> Maybe Int
yy0 _s _n =
    case _s.cond of
        _c | YYC_init == _c ->
            yyfninit _s _n
        _c | YYC_bin == _c ->
            yyfnbin _s _n
        _c | YYC_oct == _c ->
            yyfnoct _s _n
        _c | YYC_dec == _c ->
            yyfndec _s _n
        _c | YYC_hex == _c ->
            yyfnhex _s _n
        _c | True ->
            error "internal lexer error"

parse :: State -> Int -> Maybe Int
parse _s _n =
    yy0 _s _n



test :: BS.ByteString -> Maybe Int -> IO ()
test str expect = do
    let s = State {str = str, cur = 0, mar = 0, cond = YYC_init}
    when (parse s 0 /= expect) $ error "failed!"

main :: IO ()
main = do
    test "\0" Nothing
    test "1234567890\0" (Just 1234567890)
    test "0b1101\0" (Just 13)
    test "0x7Fe\0" (Just 2046)
    test "0644\0" (Just 420)
    test "9223372036854775807\0" (Just 9223372036854775807)
