-- Generated by re2c
#1 "haskell/reuse/reuse.re"
-- re2hs $INPUT -o $OUTPUT --input-encoding utf8
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}

-- This example supports multiple input encodings: UTF-8 and UTF-32.
-- Both lexers are generated from the same rules block, and the use
-- blocks add only encoding-specific configurations.

import Control.Monad (when)
import Data.Array as A
import Data.Word

data State a = State {
    str :: a,
    cur :: Int,
    mar :: Int
} deriving (Show)

#27 "haskell/reuse/reuse.re"



#26 "haskell/reuse/reuse.hs"
yy0 :: State (A.Array Int Word8) -> Maybe Int
yy0 _s =
    let yych = _s.str ! _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0xE2 == _c ->
            yy3 _s
        _c | True ->
            yy1 _s

yy1 :: State (A.Array Int Word8) -> Maybe Int
yy1 _s =
    yy2 _s

yy2 :: State (A.Array Int Word8) -> Maybe Int
yy2 _s =
#26 "haskell/reuse/reuse.re"
    Nothing
#45 "haskell/reuse/reuse.hs"

yy3 :: State (A.Array Int Word8) -> Maybe Int
yy3 _s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = _s.str ! _s.cur in
    case yych of
        _c | 0x88 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy4 _s
        _c | True ->
            yy2 _s

yy4 :: State (A.Array Int Word8) -> Maybe Int
yy4 _s =
    let yych = _s.str ! _s.cur in
    case yych of
        _c | 0x80 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy6 _s
        _c | True ->
            yy5 _s

yy5 :: State (A.Array Int Word8) -> Maybe Int
yy5 _s =
    let _t = _s{cur = _s.mar} in let _s = _t in
    yy2 _s

yy6 :: State (A.Array Int Word8) -> Maybe Int
yy6 _s =
    let yych = _s.str ! _s.cur in
    case yych of
        _c | 0x78 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | True ->
            yy5 _s

yy7 :: State (A.Array Int Word8) -> Maybe Int
yy7 _s =
    let yych = _s.str ! _s.cur in
    case yych of
        _c | 0x20 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy8 _s
        _c | True ->
            yy5 _s

yy8 :: State (A.Array Int Word8) -> Maybe Int
yy8 _s =
    let yych = _s.str ! _s.cur in
    case yych of
        _c | 0xE2 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy9 _s
        _c | True ->
            yy5 _s

yy9 :: State (A.Array Int Word8) -> Maybe Int
yy9 _s =
    let yych = _s.str ! _s.cur in
    case yych of
        _c | 0x88 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy10 _s
        _c | True ->
            yy5 _s

yy10 :: State (A.Array Int Word8) -> Maybe Int
yy10 _s =
    let yych = _s.str ! _s.cur in
    case yych of
        _c | 0x83 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy11 _s
        _c | True ->
            yy5 _s

yy11 :: State (A.Array Int Word8) -> Maybe Int
yy11 _s =
    let yych = _s.str ! _s.cur in
    case yych of
        _c | 0x79 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy12 _s
        _c | True ->
            yy5 _s

yy12 :: State (A.Array Int Word8) -> Maybe Int
yy12 _s =
#25 "haskell/reuse/reuse.re"
    Just _s.cur
#137 "haskell/reuse/reuse.hs"

lex8 :: State (A.Array Int Word8) -> Maybe Int
lex8 _s =
    yy0 _s

#34 "haskell/reuse/reuse.re"



#147 "haskell/reuse/reuse.hs"
yy13 :: State (A.Array Int Int) -> Maybe Int
yy13 _s =
    let yych = _s.str ! _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    if yych == 0x00002200 then yy16 _s
    else yy14 _s

yy14 :: State (A.Array Int Int) -> Maybe Int
yy14 _s =
    yy15 _s

yy15 :: State (A.Array Int Int) -> Maybe Int
yy15 _s =
#26 "haskell/reuse/reuse.re"
    Nothing
#163 "haskell/reuse/reuse.hs"

yy16 :: State (A.Array Int Int) -> Maybe Int
yy16 _s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = _s.str ! _s.cur in
    if yych == 0x00000078 then
        let _t = _s{cur = _s.cur + 1} in let _s = _t in
        yy17 _s
    else
        yy15 _s

yy17 :: State (A.Array Int Int) -> Maybe Int
yy17 _s =
    let yych = _s.str ! _s.cur in
    if yych == 0x00000020 then
        let _t = _s{cur = _s.cur + 1} in let _s = _t in
        yy19 _s
    else
        yy18 _s

yy18 :: State (A.Array Int Int) -> Maybe Int
yy18 _s =
    let _t = _s{cur = _s.mar} in let _s = _t in
    yy15 _s

yy19 :: State (A.Array Int Int) -> Maybe Int
yy19 _s =
    let yych = _s.str ! _s.cur in
    if yych == 0x00002203 then
        let _t = _s{cur = _s.cur + 1} in let _s = _t in
        yy20 _s
    else
        yy18 _s

yy20 :: State (A.Array Int Int) -> Maybe Int
yy20 _s =
    let yych = _s.str ! _s.cur in
    if yych == 0x00000079 then
        let _t = _s{cur = _s.cur + 1} in let _s = _t in
        yy21 _s
    else
        yy18 _s

yy21 :: State (A.Array Int Int) -> Maybe Int
yy21 _s =
#25 "haskell/reuse/reuse.re"
    Just _s.cur
#211 "haskell/reuse/reuse.hs"

lex32 :: State (A.Array Int Int) -> Maybe Int
lex32 _s =
    yy13 _s

#41 "haskell/reuse/reuse.re"


main :: IO ()
main = do
    let str8 = [0xe2, 0x88, 0x80, 0x78, 0x20, 0xe2, 0x88, 0x83, 0x79]
    let st8 = State {str = listArray (0, length str8 - 1) str8, cur = 0, mar = 0}
    when (lex8 st8 /= Just (length str8)) $ error "lex8 failed"

    let str32 = [0x2200, 0x78, 0x20, 0x2203, 0x79]
    let st32 = State {str = listArray (0, length str32 - 1) str32, cur = 0, mar = 0}
    when (lex32 st32 /= Just (length str32)) $ error "lex32 failed"
