-- Generated by re2c
#1 "haskell/reuse/reuse.re"
-- re2hs $INPUT -o $OUTPUT --input-encoding utf8
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- This example supports multiple input encodings: UTF-8 and UTF-32.
-- Both lexers are generated from the same rules block, and the use
-- blocks add only encoding-specific configurations.

import Control.Monad (when)
import Data.Array as A
import Data.Word

data State a = State {
    _str :: a,
    _cur :: Int,
    _mar :: Int
} deriving (Show)

#28 "haskell/reuse/reuse.re"



#27 "haskell/reuse/reuse.hs"
yy0 :: State (A.Array Int Word8) -> Maybe Int
yy0 State{..} =
    let yych = _str ! _cur in
    let cur = _cur + 1 in let _cur = cur in
    case yych of
        _c | 0xE2 == _c ->
            yy3 State{..}
        _c | True ->
            yy1 State{..}

yy1 :: State (A.Array Int Word8) -> Maybe Int
yy1 State{..} =
    yy2 State{..}

yy2 :: State (A.Array Int Word8) -> Maybe Int
yy2 State{..} =
#27 "haskell/reuse/reuse.re"
    Nothing
#46 "haskell/reuse/reuse.hs"

yy3 :: State (A.Array Int Word8) -> Maybe Int
yy3 State{..} =
    let _mar = _cur in
    let yych = _str ! _cur in
    case yych of
        _c | 0x88 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy4 State{..}
        _c | True ->
            yy2 State{..}

yy4 :: State (A.Array Int Word8) -> Maybe Int
yy4 State{..} =
    let yych = _str ! _cur in
    case yych of
        _c | 0x80 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy6 State{..}
        _c | True ->
            yy5 State{..}

yy5 :: State (A.Array Int Word8) -> Maybe Int
yy5 State{..} =
    let _cur = _mar in
    yy2 State{..}

yy6 :: State (A.Array Int Word8) -> Maybe Int
yy6 State{..} =
    let yych = _str ! _cur in
    case yych of
        _c | 0x78 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy7 State{..}
        _c | True ->
            yy5 State{..}

yy7 :: State (A.Array Int Word8) -> Maybe Int
yy7 State{..} =
    let yych = _str ! _cur in
    case yych of
        _c | 0x20 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy8 State{..}
        _c | True ->
            yy5 State{..}

yy8 :: State (A.Array Int Word8) -> Maybe Int
yy8 State{..} =
    let yych = _str ! _cur in
    case yych of
        _c | 0xE2 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy9 State{..}
        _c | True ->
            yy5 State{..}

yy9 :: State (A.Array Int Word8) -> Maybe Int
yy9 State{..} =
    let yych = _str ! _cur in
    case yych of
        _c | 0x88 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy10 State{..}
        _c | True ->
            yy5 State{..}

yy10 :: State (A.Array Int Word8) -> Maybe Int
yy10 State{..} =
    let yych = _str ! _cur in
    case yych of
        _c | 0x83 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy11 State{..}
        _c | True ->
            yy5 State{..}

yy11 :: State (A.Array Int Word8) -> Maybe Int
yy11 State{..} =
    let yych = _str ! _cur in
    case yych of
        _c | 0x79 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy12 State{..}
        _c | True ->
            yy5 State{..}

yy12 :: State (A.Array Int Word8) -> Maybe Int
yy12 State{..} =
#26 "haskell/reuse/reuse.re"
    Just _cur
#138 "haskell/reuse/reuse.hs"

lex8 :: State (A.Array Int Word8) -> Maybe Int
lex8 State{..} =
    yy0 State{..}

#35 "haskell/reuse/reuse.re"



#148 "haskell/reuse/reuse.hs"
yy13 :: State (A.Array Int Int) -> Maybe Int
yy13 State{..} =
    let yych = _str ! _cur in
    let cur = _cur + 1 in let _cur = cur in
    if yych == 0x00002200 then yy16 State{..}
    else yy14 State{..}

yy14 :: State (A.Array Int Int) -> Maybe Int
yy14 State{..} =
    yy15 State{..}

yy15 :: State (A.Array Int Int) -> Maybe Int
yy15 State{..} =
#27 "haskell/reuse/reuse.re"
    Nothing
#164 "haskell/reuse/reuse.hs"

yy16 :: State (A.Array Int Int) -> Maybe Int
yy16 State{..} =
    let _mar = _cur in
    let yych = _str ! _cur in
    if yych == 0x00000078 then
        let cur = _cur + 1 in let _cur = cur in
        yy17 State{..}
    else
        yy15 State{..}

yy17 :: State (A.Array Int Int) -> Maybe Int
yy17 State{..} =
    let yych = _str ! _cur in
    if yych == 0x00000020 then
        let cur = _cur + 1 in let _cur = cur in
        yy19 State{..}
    else
        yy18 State{..}

yy18 :: State (A.Array Int Int) -> Maybe Int
yy18 State{..} =
    let _cur = _mar in
    yy15 State{..}

yy19 :: State (A.Array Int Int) -> Maybe Int
yy19 State{..} =
    let yych = _str ! _cur in
    if yych == 0x00002203 then
        let cur = _cur + 1 in let _cur = cur in
        yy20 State{..}
    else
        yy18 State{..}

yy20 :: State (A.Array Int Int) -> Maybe Int
yy20 State{..} =
    let yych = _str ! _cur in
    if yych == 0x00000079 then
        let cur = _cur + 1 in let _cur = cur in
        yy21 State{..}
    else
        yy18 State{..}

yy21 :: State (A.Array Int Int) -> Maybe Int
yy21 State{..} =
#26 "haskell/reuse/reuse.re"
    Just _cur
#212 "haskell/reuse/reuse.hs"

lex32 :: State (A.Array Int Int) -> Maybe Int
lex32 State{..} =
    yy13 State{..}

#42 "haskell/reuse/reuse.re"


main :: IO ()
main = do
    let make_st l = State {_str = listArray (0, length l - 1) l, _cur = 0, _mar = 0}

    let s8 = [0xe2, 0x88, 0x80, 0x78, 0x20, 0xe2, 0x88, 0x83, 0x79]
    when (lex8 (make_st s8) /= Just (length s8)) $ error "lex8 failed"

    let s32 = [0x2200, 0x78, 0x20, 0x2203, 0x79]
    when (lex32 (make_st s32) /= Just (length s32)) $ error "lex32 failed"
