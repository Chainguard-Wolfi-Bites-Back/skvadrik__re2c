-- Generated by re2c
#1 "haskell/reuse/usedir.re"
-- re2hs $INPUT -o $OUTPUT
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}

-- This example shows how to combine reusable re2c blocks: two blocks
-- ('colors' and 'fish') are merged into one. The 'salmon' rule occurs
-- in both blocks; the 'fish' block takes priority because it is used
-- earlier. Default rule * occurs in all three blocks; the local (not
-- inherited) definition takes priority.

import Control.Monad (when)
import Data.ByteString as BS

data Answer = Color | Fish | Dunno deriving (Eq)

data State = State {
    str :: BS.ByteString,
    cur :: Int,
    mar :: Int
} deriving (Show)

#25 "haskell/reuse/usedir.re"


#30 "haskell/reuse/usedir.re"



#32 "haskell/reuse/usedir.hs"
yy0 :: State -> Answer
yy0 _s =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x65 == _c ->
            yy3 _s
        _c | 0x68 == _c ->
            yy4 _s
        _c | 0x6D == _c ->
            yy5 _s
        _c | 0x72 == _c ->
            yy6 _s
        _c | 0x73 == _c ->
            yy7 _s
        _c | True ->
            yy1 _s

yy1 :: State -> Answer
yy1 _s =
    yy2 _s

yy2 :: State -> Answer
yy2 _s =
#43 "haskell/reuse/usedir.re"
    Dunno
#59 "haskell/reuse/usedir.hs"

yy3 :: State -> Answer
yy3 _s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x65 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy8 _s
        _c | True ->
            yy2 _s

yy4 :: State -> Answer
yy4 _s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x61 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy10 _s
        _c | True ->
            yy2 _s

yy5 :: State -> Answer
yy5 _s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x61 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy11 _s
        _c | True ->
            yy2 _s

yy6 :: State -> Answer
yy6 _s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x65 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy12 _s
        _c | True ->
            yy2 _s

yy7 :: State -> Answer
yy7 _s =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x61 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy13 _s
        _c | True ->
            yy2 _s

yy8 :: State -> Answer
yy8 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x6C == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy14 _s
        _c | True ->
            yy9 _s

yy9 :: State -> Answer
yy9 _s =
    let _t = _s{cur = _s.mar} in let _s = _t in
    yy2 _s

yy10 :: State -> Answer
yy10 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x64 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy15 _s
        _c | True ->
            yy9 _s

yy11 :: State -> Answer
yy11 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x67 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy16 _s
        _c | True ->
            yy9 _s

yy12 :: State -> Answer
yy12 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x64 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy17 _s
        _c | True ->
            yy9 _s

yy13 :: State -> Answer
yy13 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x6C == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy18 _s
        _c | True ->
            yy9 _s

yy14 :: State -> Answer
yy14 _s =
#29 "haskell/reuse/usedir.re"
    Fish
#175 "haskell/reuse/usedir.hs"

yy15 :: State -> Answer
yy15 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x64 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy19 _s
        _c | True ->
            yy9 _s

yy16 :: State -> Answer
yy16 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x65 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy20 _s
        _c | True ->
            yy9 _s

yy17 :: State -> Answer
yy17 _s =
#24 "haskell/reuse/usedir.re"
    Color
#201 "haskell/reuse/usedir.hs"

yy18 :: State -> Answer
yy18 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x6D == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy21 _s
        _c | True ->
            yy9 _s

yy19 :: State -> Answer
yy19 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x6F == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy22 _s
        _c | True ->
            yy9 _s

yy20 :: State -> Answer
yy20 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x6E == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy23 _s
        _c | True ->
            yy9 _s

yy21 :: State -> Answer
yy21 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x6F == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy24 _s
        _c | True ->
            yy9 _s

yy22 :: State -> Answer
yy22 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x63 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy25 _s
        _c | True ->
            yy9 _s

yy23 :: State -> Answer
yy23 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x74 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy26 _s
        _c | True ->
            yy9 _s

yy24 :: State -> Answer
yy24 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x6E == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy14 _s
        _c | True ->
            yy9 _s

yy25 :: State -> Answer
yy25 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x6B == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy14 _s
        _c | True ->
            yy9 _s

yy26 :: State -> Answer
yy26 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x61 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy17 _s
        _c | True ->
            yy9 _s

lexer :: State -> Answer
lexer _s =
    yy0 _s

#44 "haskell/reuse/usedir.re"


main :: IO ()
main = do
    let test str ans = do
            let st = State {str = str, cur = 0, mar = 0}
            when (lexer st /= ans) $ error "failed"

    test "salmon" Fish
    test "what?" Dunno
