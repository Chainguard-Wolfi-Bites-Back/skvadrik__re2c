-- Generated by re2c
-- re2hs $INPUT -o $OUTPUT -i
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}

import Control.Monad (when)
import Data.ByteString as BS

data Number = INum | FNum | NNaN deriving (Eq)




data State = State {
    str :: BS.ByteString,
    cur :: Int,
    mar :: Int,
    accept :: Int
} deriving (Show)


yy0 :: State -> Number
yy0 _s =
    let yych = BS.index _s.str _s.cur in
    let _t = _s{cur = _s.cur + 1} in let _s = _t in
    case yych of
        _c | 0x2E == _c ->
            yy3 _s
        _c | 0x30 == _c ->
            yy4 _s
        _c | 0x31 <= _c && _c <= 0x39 ->
            yy5 _s
        _c | True ->
            yy1 _s

yy1 :: State -> Number
yy1 _s =
    yy2 _s

yy2 :: State -> Number
yy2 _s =
    NNaN

yy3 :: State -> Number
yy3 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | True ->
            yy2 _s

yy4 :: State -> Number
yy4 _s =
    let _t = _s{accept = 0} in let _s = _t in
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x2E == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy9 _s
        _c | 0x45 == _c || 0x65 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy11 _s
        _c | True ->
            yy2 _s

yy5 :: State -> Number
yy5 _s =
    let _t = _s{accept = 1} in let _s = _t in
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x2E == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy5 _s
        _c | 0x45 == _c || 0x65 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy11 _s
        _c | True ->
            yy6 _s

yy6 :: State -> Number
yy6 _s =
    INum

yy7 :: State -> Number
yy7 _s =
    let _t = _s{accept = 2} in let _s = _t in
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | 0x45 == _c || 0x65 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy11 _s
        _c | True ->
            yy8 _s

yy8 :: State -> Number
yy8 _s =
    FNum

yy9 :: State -> Number
yy9 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x2E == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy7 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy9 _s
        _c | 0x45 == _c || 0x65 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy11 _s
        _c | True ->
            yy10 _s

yy10 :: State -> Number
yy10 _s =
    let _t = _s{cur = _s.mar} in let _s = _t in
    case _s.accept of
        _c | 0 == _c ->
            yy2 _s
        _c | 1 == _c ->
            yy6 _s
        _c | True ->
            yy8 _s

yy11 :: State -> Number
yy11 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x2B == _c || 0x2D == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy12 _s
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy13 _s
        _c | True ->
            yy10 _s

yy12 :: State -> Number
yy12 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy13 _s
        _c | True ->
            yy10 _s

yy13 :: State -> Number
yy13 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy13 _s
        _c | True ->
            yy8 _s

lexer :: State -> Number
lexer _s =
    yy0 _s



main :: IO ()
main = do
    let test s n = do
            let st = State {str = s, cur = 0, mar = 0, accept = 0}
            when (lexer st /= n) $ error "failed"

    test "123\0" INum
    test "123.4567\0" FNum
