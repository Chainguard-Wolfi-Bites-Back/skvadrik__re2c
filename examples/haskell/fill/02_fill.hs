-- Generated by re2c
#1 "haskell/fill/02_fill.re"
-- re2hs $INPUT -o $OUTPUT
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad
import Data.ByteString as BS
import GHC.IO.Handle
import System.Directory
import System.IO

chunk_size :: Int
chunk_size = 4096

data State = State {
    file :: !Handle,
    buf :: !BS.ByteString,
    cur :: !Int,
    lim :: !Int,
    tok :: !Int,
    eof :: !Bool
} deriving (Show)


#27 "haskell/fill/02_fill.hs"
yy0 :: State -> Int -> IO Int
yy0 !_st !_count = do
    _st <- fill _st 1
    yych <- return $ BS.index _st.buf _st.cur
    _st <- return _st{cur = _st.cur + 1}
    case yych of
        _c | 0x00 == _c -> do
            yy1 _st _count
        _c | 0x20 == _c -> do
            yy3 _st _count
        _c | 0x27 == _c -> do
            yy5 _st _count
        _c | True -> do
            yy2 _st _count

yy1 :: State -> Int -> IO Int
yy1 !_st !_count = do
#38 "haskell/fill/02_fill.re"
    return $ if _st.cur == _st.lim - yymaxfill + 1 then _count else (-1)
#47 "haskell/fill/02_fill.hs"

yy2 :: State -> Int -> IO Int
yy2 !_st !_count = do
#37 "haskell/fill/02_fill.re"
    return (-1)
#53 "haskell/fill/02_fill.hs"

yy3 :: State -> Int -> IO Int
yy3 !_st !_count = do
    _st <- fill _st 1
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x20 == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy3 _st _count
        _c | True -> do
            yy4 _st _count

yy4 :: State -> Int -> IO Int
yy4 !_st !_count = do
#40 "haskell/fill/02_fill.re"
    lexer _st{tok = _st.cur} _count
#70 "haskell/fill/02_fill.hs"

yy5 :: State -> Int -> IO Int
yy5 !_st !_count = do
    _st <- fill _st 1
    yych <- return $ BS.index _st.buf _st.cur
    _st <- return _st{cur = _st.cur + 1}
    case yych of
        _c | 0x27 == _c -> do
            yy6 _st _count
        _c | 0x5C == _c -> do
            yy7 _st _count
        _c | True -> do
            yy5 _st _count

yy6 :: State -> Int -> IO Int
yy6 !_st !_count = do
#39 "haskell/fill/02_fill.re"
    lexer _st{tok = _st.cur} (_count + 1)
#89 "haskell/fill/02_fill.hs"

yy7 :: State -> Int -> IO Int
yy7 !_st !_count = do
    _st <- fill _st 1
    _st <- return _st{cur = _st.cur + 1}
    yy5 _st _count

lexer :: State -> Int -> IO Int
lexer !_st !_count = do
    yy0 _st _count

#41 "haskell/fill/02_fill.re"


yymaxfill :: Int
#105 "haskell/fill/02_fill.hs"
yymaxfill = 1
#44 "haskell/fill/02_fill.re"


fill :: State -> Int -> IO State
fill !st !need =
    if (st.lim - st.cur >= need) then
        return st
    else case st.eof of
        True -> error "fill failed"
        False -> do
            -- Discard everything up to the current token, cut off terminating null,
            -- read new chunk from file and reappend terminating null at the end.
            chunk <- BS.hGet st.file chunk_size
            let !eof' = BS.length chunk < need -- end of file ?
            let !buf' = BS.concat
                    [ BS.drop st.tok st.buf
                    , chunk
                    , if eof' then (BS.replicate yymaxfill 0) else BS.empty
                    ]
            return st {
                buf = buf',
                cur = st.cur - st.tok,
                lim = BS.length buf',
                tok = 0,
                eof = eof'
            }

main :: IO ()
main = do
    let fname = "input"

    -- Prepare input file.
    BS.writeFile fname $ BS.concat ["'qu\0tes' 'are' 'fine: \\'' " | _ <- [1..chunk_size]]
    let expect = 3 * chunk_size -- the total number of strings in file

    -- Run lexer on the prepared file.
    fh <- openFile fname ReadMode
    let st = State {
        file = fh,
        buf = BS.empty,
        cur = 0,
        tok = 0,
        lim = 0,
        eof = False
    }
    result <- lexer st 0
    hClose fh

    -- Cleanup.
    removeFile fname

    -- Check result.
    when (result /= expect) $ error $ "expected " ++ show expect ++ ", got " ++ show result
    return ()
