-- Generated by re2c
#1 "haskell/fill/01_fill.re"
-- re2hs $INPUT -o $OUTPUT
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad
import Data.ByteString as BS
import Data.Word
import GHC.IO.Handle
import System.Directory
import System.IO

chunk_size :: Int
chunk_size = 4096

data State = State {
    file :: !Handle,
    buf :: !BS.ByteString,
    cur :: !Int,
    mar :: !Int,
    lim :: !Int,
    tok :: !Int,
    eof :: !Bool
} deriving (Show)


#29 "haskell/fill/01_fill.hs"
yy0 :: State -> Int -> IO Int
yy0 !_st !_count = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x20 == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy3 _st _count
        _c | 0x27 == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy5 _st _count
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy0 _st _count
                else yy10 _st _count
            else do
                _st <- return _st{cur = _st.cur + 1}
                yy1 _st _count

yy1 :: State -> Int -> IO Int
yy1 !_st !_count = do
    yy2 _st _count

yy2 :: State -> Int -> IO Int
yy2 !_st !_count = do
#39 "haskell/fill/01_fill.re"
    return (-1)
#57 "haskell/fill/01_fill.hs"

yy3 :: State -> Int -> IO Int
yy3 !_st !_count = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x20 == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy3 _st _count
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy3 _st _count
                else yy4 _st _count
            else do
                yy4 _st _count

yy4 :: State -> Int -> IO Int
yy4 !_st !_count = do
#42 "haskell/fill/01_fill.re"
    lexer _st{tok = _st.cur} _count
#78 "haskell/fill/01_fill.hs"

yy5 :: State -> Int -> IO Int
yy5 !_st !_count = do
    _st <- return _st{mar = _st.cur}
    yych <- return $ BS.index _st.buf _st.cur
    if yych <= 0x00 then do
        if _st.cur >= _st.lim then do
            (_st, yyfill) <- fill _st
            if yyfill then yy5 _st _count
            else yy2 _st _count
        else do
            _st <- return _st{cur = _st.cur + 1}
            yy6 _st _count
    else do
        yy7 _st _count yych

yy6 :: State -> Int -> IO Int
yy6 !_st !_count = do
    yych <- return $ BS.index _st.buf _st.cur
    yy7 _st _count yych

yy7 :: State -> Int -> Word8 -> IO Int
yy7 !_st !_count yych = do
    case yych of
        _c | 0x27 == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy8 _st _count
        _c | 0x5C == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy9 _st _count
        _c | True -> do
            if _st.cur >= _st.lim then do
                (_st, yyfill) <- fill _st
                if yyfill then yy6 _st _count
                else yy11 _st _count
            else do
                _st <- return _st{cur = _st.cur + 1}
                yy6 _st _count

yy8 :: State -> Int -> IO Int
yy8 !_st !_count = do
#41 "haskell/fill/01_fill.re"
    lexer _st{tok = _st.cur} (_count + 1)
#122 "haskell/fill/01_fill.hs"

yy9 :: State -> Int -> IO Int
yy9 !_st !_count = do
    yych <- return $ BS.index _st.buf _st.cur
    if yych <= 0x00 then do
        if _st.cur >= _st.lim then do
            (_st, yyfill) <- fill _st
            if yyfill then yy9 _st _count
            else yy11 _st _count
        else do
            _st <- return _st{cur = _st.cur + 1}
            yy6 _st _count
    else do
        _st <- return _st{cur = _st.cur + 1}
        yy6 _st _count

yy10 :: State -> Int -> IO Int
yy10 !_st !_count = do
#40 "haskell/fill/01_fill.re"
    return _count
#143 "haskell/fill/01_fill.hs"

yy11 :: State -> Int -> IO Int
yy11 !_st !_count = do
    _st <- return _st{cur = _st.mar}
    yy2 _st _count

lexer :: State -> Int -> IO Int
lexer !_st !_count = do
    yy0 _st _count

#43 "haskell/fill/01_fill.re"


fill :: State -> IO (State, Bool)
fill st = do
    case st.eof of
        True -> return (st, False)
        False -> do
            -- Discard everything up to the current token, cut off terminating null,
            -- read new chunk from file and reappend terminating null at the end.
            chunk <- BS.hGet st.file chunk_size
            let st' = st{
                buf = BS.concat [(BS.init . BS.drop st.tok) st.buf, chunk, "\0"],
                cur = st.cur - st.tok,
                mar = st.mar - st.tok,
                lim = st.lim - st.tok + BS.length chunk, -- exclude terminating null
                tok = 0,
                eof = BS.null chunk -- end of file?
            }
            return (st', True)

main :: IO ()
main = do
    let fname = "input"

    -- Prepare input file.
    BS.writeFile fname $ BS.concat ["'qu\0tes' 'are' 'fine: \\'' " | _ <- [1..chunk_size]]
    let expect = 3 * chunk_size -- the total number of strings in file

    -- Run lexer on the prepared file.
    fh <- openFile fname ReadMode
    let st = State {
        file = fh,
        buf = BS.singleton 0,
        cur = 0,
        mar = 0,
        tok = 0,
        lim = 0,
        eof = False
    }
    result <- lexer st 0
    hClose fh

    -- Cleanup.
    removeFile fname

    -- Check result.
    when (result /= expect) $ error $ "expected " ++ show expect ++ ", got " ++ show result
    return ()
