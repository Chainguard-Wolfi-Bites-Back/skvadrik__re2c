-- Generated by re2c
#1 "haskell/fill/01_fill.re"
-- re2hs $INPUT -o $OUTPUT
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

import Control.Monad
import Data.ByteString as BS
import Data.Word
import GHC.IO.Handle
import System.Directory
import System.IO

chunk_size :: Int
chunk_size = 4096

data State = State {
    _file :: !Handle,
    _buf :: !BS.ByteString,
    _cur :: !Int,
    _mar :: !Int,
    _lim :: !Int,
    _tok :: !Int,
    _eof :: !Bool
} deriving (Show)


#30 "haskell/fill/01_fill.hs"
yy0 :: State -> Int -> IO Int
yy0 !State{..} !_count = do
    yych <- return $ BS.index _buf _cur
    case yych of
        _c | 0x20 == _c -> do
            _cur <- return $ _cur + 1
            yy3 State{..} _count
        _c | 0x27 == _c -> do
            _cur <- return $ _cur + 1
            yy5 State{..} _count
        _c | True -> do
            if _cur >= _lim then do
                (State{..}, yyfill) <- fill State{..}
                if yyfill then yy0 State{..} _count
                else yy10 State{..} _count
            else do
                _cur <- return $ _cur + 1
                yy1 State{..} _count

yy1 :: State -> Int -> IO Int
yy1 !State{..} !_count = do
    yy2 State{..} _count

yy2 :: State -> Int -> IO Int
yy2 !State{..} !_count = do
#40 "haskell/fill/01_fill.re"
    return (-1)
#58 "haskell/fill/01_fill.hs"

yy3 :: State -> Int -> IO Int
yy3 !State{..} !_count = do
    yych <- return $ BS.index _buf _cur
    case yych of
        _c | 0x20 == _c -> do
            _cur <- return $ _cur + 1
            yy3 State{..} _count
        _c | True -> do
            if _cur >= _lim then do
                (State{..}, yyfill) <- fill State{..}
                if yyfill then yy3 State{..} _count
                else yy4 State{..} _count
            else do
                yy4 State{..} _count

yy4 :: State -> Int -> IO Int
yy4 !State{..} !_count = do
#43 "haskell/fill/01_fill.re"
    lexer State{_tok = _cur, ..} _count
#79 "haskell/fill/01_fill.hs"

yy5 :: State -> Int -> IO Int
yy5 !State{..} !_count = do
    let _mar = _cur
    yych <- return $ BS.index _buf _cur
    if yych <= 0x00 then do
        if _cur >= _lim then do
            (State{..}, yyfill) <- fill State{..}
            if yyfill then yy5 State{..} _count
            else yy2 State{..} _count
        else do
            _cur <- return $ _cur + 1
            yy6 State{..} _count
    else do
        yy7 State{..} _count yych

yy6 :: State -> Int -> IO Int
yy6 !State{..} !_count = do
    yych <- return $ BS.index _buf _cur
    yy7 State{..} _count yych

yy7 :: State -> Int -> Word8 -> IO Int
yy7 !State{..} !_count yych = do
    case yych of
        _c | 0x27 == _c -> do
            _cur <- return $ _cur + 1
            yy8 State{..} _count
        _c | 0x5C == _c -> do
            _cur <- return $ _cur + 1
            yy9 State{..} _count
        _c | True -> do
            if _cur >= _lim then do
                (State{..}, yyfill) <- fill State{..}
                if yyfill then yy6 State{..} _count
                else yy11 State{..} _count
            else do
                _cur <- return $ _cur + 1
                yy6 State{..} _count

yy8 :: State -> Int -> IO Int
yy8 !State{..} !_count = do
#42 "haskell/fill/01_fill.re"
    lexer State{_tok = _cur, ..} (_count + 1)
#123 "haskell/fill/01_fill.hs"

yy9 :: State -> Int -> IO Int
yy9 !State{..} !_count = do
    yych <- return $ BS.index _buf _cur
    if yych <= 0x00 then do
        if _cur >= _lim then do
            (State{..}, yyfill) <- fill State{..}
            if yyfill then yy9 State{..} _count
            else yy11 State{..} _count
        else do
            _cur <- return $ _cur + 1
            yy6 State{..} _count
    else do
        _cur <- return $ _cur + 1
        yy6 State{..} _count

yy10 :: State -> Int -> IO Int
yy10 !State{..} !_count = do
#41 "haskell/fill/01_fill.re"
    return _count
#144 "haskell/fill/01_fill.hs"

yy11 :: State -> Int -> IO Int
yy11 !State{..} !_count = do
    let _cur = _mar
    yy2 State{..} _count

lexer :: State -> Int -> IO Int
lexer !State{..} !_count = do
    yy0 State{..} _count

#44 "haskell/fill/01_fill.re"


fill :: State -> IO (State, Bool)
fill State{..} = do
    case _eof of
        True -> return (State{..}, False)
        False -> do
            -- Discard everything up to the current token, cut off terminating null,
            -- read new chunk from file and reappend terminating null at the end.
            chunk <- BS.hGet _file chunk_size
            return (State {
                _buf = BS.concat [(BS.init . BS.drop _tok) _buf, chunk, "\0"],
                _cur = _cur - _tok,
                _mar = _mar - _tok,
                _lim = _lim - _tok + BS.length chunk, -- exclude terminating null
                _tok = 0,
                _eof = BS.null chunk, -- end of file?
                ..}, True)

main :: IO ()
main = do
    let fname = "input"

    -- Prepare input file.
    BS.writeFile fname $ BS.concat ["'qu\0tes' 'are' 'fine: \\'' " | _ <- [1..chunk_size]]
    let expect = 3 * chunk_size -- the total number of strings in file

    -- Run lexer on the prepared file.
    fh <- openFile fname ReadMode
    let st = State {
        _file = fh,
        _buf = BS.singleton 0,
        _cur = 0,
        _mar = 0,
        _tok = 0,
        _lim = 0,
        _eof = False
    }
    result <- lexer st 0
    hClose fh

    -- Cleanup.
    removeFile fname

    -- Check result.
    when (result /= expect) $ error $ "expected " ++ show expect ++ ", got " ++ show result
    return ()
