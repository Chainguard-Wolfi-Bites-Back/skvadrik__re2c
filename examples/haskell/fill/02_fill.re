-- re2hs $INPUT -o $OUTPUT
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad
import qualified Data.ByteString as BS
import GHC.IO.Handle
import System.Directory
import System.IO

chunk_size :: Int
chunk_size = 4096

data State = State {
    _file :: !Handle,
    _str :: !BS.ByteString,
    _cur :: !Int,
    _lim :: !Int,
    _tok :: !Int,
    _eof :: !Bool,
    _cnt :: !Int
}

/*!re2c
    re2c:define:YYFN = ["lexer;IO Int", "State{..};State;!State{..}"];
    re2c:define:YYPEEK = "BS.index";

    // We have to turn off autogenerated YFILL check and write it manually as part of YYFILL
    // implementation, so that we can propagate the updated state out of it.
    re2c:yyfill:check = 0;
    re2c:define:YYFILL = "State{..} <- fill State{..} @@";
    re2c:monadic = 1;

    str = ['] ([^'\\] | [\\][^])* ['];

    *      { return (-1) }
    [\x00] { return $ if _cur == _lim - yymaxfill + 1 then _cnt else (-1) }
    str    { lexer State{_tok = _cur, _cnt = _cnt + 1, ..} }
    [ ]+   { lexer State{_tok = _cur, ..} }
*/

yymaxfill :: Int
/*!max:re2c*/

fill :: State -> Int -> IO State
fill !st@State{..} !need =
    if _lim - _cur >= need then
        return st
    else case _eof of
        True -> error "fill failed"
        False -> do
            -- Discard everything up to the current token, cut off terminating null,
            -- read new chunk from file and reappend terminating null at the end.
            chunk <- BS.hGet _file chunk_size
            let !eof = BS.length chunk < need -- end of file ?
            let !buf = BS.concat [
                    BS.drop _tok _str,
                    chunk,
                    if eof then (BS.replicate yymaxfill 0) else BS.empty]
            return State {
                _str = buf,
                _cur = _cur - _tok,
                _lim = BS.length buf,
                _tok = 0,
                _eof = eof,
                ..}

main :: IO ()
main = do
    let fname = "input"

    -- Prepare input file.
    BS.writeFile fname $ BS.concat ["'qu\0tes' 'are' 'fine: \\'' " | _ <- [1..chunk_size]]
    let expect = 3 * chunk_size -- the total number of strings in file

    -- Run lexer on the prepared file.
    fh <- openFile fname ReadMode
    let st = State {
        _file = fh,
        _str = BS.empty,
        _cur = 0,
        _tok = 0,
        _lim = 0,
        _eof = False,
        _cnt = 0
    }
    result <- lexer st
    hClose fh

    -- Cleanup.
    removeFile fname

    -- Check result.
    when (result /= expect) $ error $ "expected " ++ show expect ++ ", got " ++ show result
    return ()
