-- Generated by re2c
-- re2hs $INPUT -o $OUTPUT -fi
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Concurrent.Chan
import Control.Monad
import Data.ByteString as BS
import Text.Printf

debug :: PrintfType r => String -> r
debug format = printf format

data State = State {
    pipe :: !(Chan BS.ByteString),
    buf :: !BS.ByteString,
    cur :: !Int,
    mar :: !Int,
    lim :: !Int,
    tok :: !Int,
    eof :: !Bool,
    state :: !Int,
    recv :: !Int
}

data Status = End | Ready | Waiting | BadPacket deriving (Eq)


yy0 :: State -> IO (State, Status)
yy0 !_st = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x61 <= _c && _c <= 0x7A -> do
            _st <- return _st{cur = _st.cur + 1}
            yy3 _st
        _c | True -> do
            if _st.cur >= _st.lim then do
                _st <- return _st{state = 0}
                return (_st, Waiting)
            else do
                _st <- return _st{cur = _st.cur + 1}
                yy1 _st

yy1 :: State -> IO (State, Status)
yy1 !_st = do
    yy2 _st

yy2 :: State -> IO (State, Status)
yy2 !_st = do
    _st <- return _st{state = -1}
    return (_st, BadPacket)

yy3 :: State -> IO (State, Status)
yy3 !_st = do
    _st <- return _st{mar = _st.cur}
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x3B == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy4 _st
        _c | 0x61 <= _c && _c <= 0x7A -> do
            _st <- return _st{cur = _st.cur + 1}
            yy5 _st
        _c | True -> do
            if _st.cur >= _st.lim then do
                _st <- return _st{state = 1}
                return (_st, Waiting)
            else do
                yy2 _st

yy4 :: State -> IO (State, Status)
yy4 !_st = do
    _st <- return _st{state = -1}
    lexer _st{tok = _st.cur, recv = _st.recv + 1}

yy5 :: State -> IO (State, Status)
yy5 !_st = do
    yych <- return $ BS.index _st.buf _st.cur
    case yych of
        _c | 0x3B == _c -> do
            _st <- return _st{cur = _st.cur + 1}
            yy4 _st
        _c | 0x61 <= _c && _c <= 0x7A -> do
            _st <- return _st{cur = _st.cur + 1}
            yy5 _st
        _c | True -> do
            if _st.cur >= _st.lim then do
                _st <- return _st{state = 2}
                return (_st, Waiting)
            else do
                yy6 _st

yy6 :: State -> IO (State, Status)
yy6 !_st = do
    _st <- return _st{cur = _st.mar}
    yy2 _st

yy7 :: State -> IO (State, Status)
yy7 !_st = do
    _st <- return _st{state = -1}
    return (_st, End)

lexer :: State -> IO (State, Status)
lexer !_st = do
    case _st.state of
        _c | -1 == _c -> do
            yy0 _st
        _c | 0 == _c -> do
            if _st.cur >= _st.lim then yy7 _st
            else yy0 _st
        _c | 1 == _c -> do
            if _st.cur >= _st.lim then yy2 _st
            else yy3 _st
        _c | 2 == _c -> do
            if _st.cur >= _st.lim then yy6 _st
            else yy5 _st
        _c | True -> do
            error "internal lexer error"



fill :: State -> IO (State, Status)
fill st = do
    case st.eof of
        True -> return (st, End)
        False -> do
            -- Discard everything up to the current token, cut off terminating null,
            -- read new chunk from file and reappend terminating null at the end.
            chunk <- readChan st.pipe
            let st' = st{
                buf = BS.concat [(BS.init . BS.drop st.tok) st.buf, chunk, "\0"],
                cur = st.cur - st.tok,
                mar = st.mar - st.tok,
                lim = st.lim - st.tok + BS.length chunk, -- exclude terminating null
                tok = 0,
                eof = BS.null chunk -- end of file?
            }
            return (st', Ready)

loop :: State -> [BS.ByteString] -> IO Status
loop st packets = do
    (st', status) <- lexer st
    case status of
        End -> do
            debug "done: got %d packets\n" st'.recv
            return End
        Waiting -> do
            debug "waiting...\n"
            packets' <- case packets of
                [] -> do
                    writeChan st'.pipe BS.empty
                    return []
                p:ps -> do
                    debug "sent packet '%s'\n" (show p)
                    writeChan st'.pipe p
                    return ps
            (st'', status') <- fill st'
            case status' of
                Ready -> loop st'' packets'
                _ -> error "unexpected status after fill"
        BadPacket -> do
            debug "error: ill-formed packet\n"
            return BadPacket
        _ -> error "unexpected status"

test :: [BS.ByteString] -> Status -> IO ()
test packets expect = do
    pipe <- newChan -- emulate pipe using a chan of bytestrings
    let st = State {
        pipe = pipe,
        buf = BS.singleton 0, -- null sentinel triggers YYFILL
        cur = 0,
        mar = 0,
        tok = 0,
        lim = 0,
        eof = False,
        state = -1,
        recv = 0
    }
    status <- loop st packets
    when (status /= expect) $ error "failed"
    return ()

main :: IO ()
main = do
    test [] End
    test ["ze", "ro;o", "ne", ";t", "wo;thr", "e", "e", ";", "four;"] End
    test ["zer0;"] BadPacket
