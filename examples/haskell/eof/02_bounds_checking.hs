-- Generated by re2c
#1 "haskell/eof/02_bounds_checking.re"
-- re2hs $INPUT -o $OUTPUT
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

import Control.Exception
import Control.Monad (when)
import Data.ByteString as BS

data State = State {
    _buf :: BS.ByteString,
    _cur :: Int,
    _lim :: Int
} deriving (Show)

data FillException = UnexpectedFill deriving (Show)
instance Exception FillException

yymaxfill :: Int
#23 "haskell/eof/02_bounds_checking.hs"
yymaxfill = 1
#20 "haskell/eof/02_bounds_checking.re"



#29 "haskell/eof/02_bounds_checking.hs"
yy0 :: State -> Int -> IO Int
yy0 State{..} _cnt = do
    when (_lim - _cur < 1) $ throw UnexpectedFill
    yych <- return $ BS.index _buf _cur
    _cur <- return $ _cur + 1
    case yych of
        _c | 0x00 == _c -> do
            yy1 State{..} _cnt
        _c | 0x20 == _c -> do
            yy3 State{..} _cnt
        _c | 0x27 == _c -> do
            yy5 State{..} _cnt
        _c | True -> do
            yy2 State{..} _cnt

yy1 :: State -> Int -> IO Int
yy1 State{..} _cnt = do
#33 "haskell/eof/02_bounds_checking.re"
    -- check that it is the sentinel, not some unexpected null
    return $ if _cur == BS.length _buf - yymaxfill + 1 then _cnt else (-1)
#50 "haskell/eof/02_bounds_checking.hs"

yy2 :: State -> Int -> IO Int
yy2 State{..} _cnt = do
#39 "haskell/eof/02_bounds_checking.re"
    return (-1)
#56 "haskell/eof/02_bounds_checking.hs"

yy3 :: State -> Int -> IO Int
yy3 State{..} _cnt = do
    when (_lim - _cur < 1) $ throw UnexpectedFill
    yych <- return $ BS.index _buf _cur
    case yych of
        _c | 0x20 == _c -> do
            _cur <- return $ _cur + 1
            yy3 State{..} _cnt
        _c | True -> do
            yy4 State{..} _cnt

yy4 :: State -> Int -> IO Int
yy4 State{..} _cnt = do
#38 "haskell/eof/02_bounds_checking.re"
    lexer State{..} _cnt
#73 "haskell/eof/02_bounds_checking.hs"

yy5 :: State -> Int -> IO Int
yy5 State{..} _cnt = do
    when (_lim - _cur < 1) $ throw UnexpectedFill
    yych <- return $ BS.index _buf _cur
    _cur <- return $ _cur + 1
    case yych of
        _c | 0x27 == _c -> do
            yy6 State{..} _cnt
        _c | 0x5C == _c -> do
            yy7 State{..} _cnt
        _c | True -> do
            yy5 State{..} _cnt

yy6 :: State -> Int -> IO Int
yy6 State{..} _cnt = do
#37 "haskell/eof/02_bounds_checking.re"
    lexer State{..} (_cnt + 1)
#92 "haskell/eof/02_bounds_checking.hs"

yy7 :: State -> Int -> IO Int
yy7 State{..} _cnt = do
    when (_lim - _cur < 1) $ throw UnexpectedFill
    _cur <- return $ _cur + 1
    yy5 State{..} _cnt

lexer :: State -> Int -> IO Int
lexer State{..} _cnt = do
    yy0 State{..} _cnt

#40 "haskell/eof/02_bounds_checking.re"


main :: IO ()
main = do
    let test s n = do
            let buf = BS.concat [s, BS.replicate yymaxfill 0]
            let st = State {_buf = buf, _cur = 0, _lim = BS.length buf}
            m <- catch (lexer st 0) (\(_ :: FillException) -> return (-2))
            when (m /= n) $ error "failed"

    test "" 0
    test "'unterminated\\'" (-2)
    test "'qu\0tes' 'are' 'fine: \\'' " 3
    test "'unexpected' \0 'null'" (-1)
