-- Generated by re2c
#1 "haskell/eof/02_bounds_checking.re"
-- re2hs $INPUT -o $OUTPUT
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}

import Control.Exception
import Control.Monad (when)
import Data.ByteString as BS

data State = State {
    buf :: BS.ByteString,
    cur :: Int,
    lim :: Int
} deriving (Show)

data FillException = UnexpectedFill deriving (Show)
instance Exception FillException

yymaxfill :: Int
#22 "haskell/eof/02_bounds_checking.hs"
yymaxfill = 1
#19 "haskell/eof/02_bounds_checking.re"



#28 "haskell/eof/02_bounds_checking.hs"
yy0 :: State -> Int -> IO Int
yy0 _s _cnt = do
    when (_s.lim - _s.cur < 1) $ throw UnexpectedFill
    yych <- return $ BS.index _s.buf _s.cur
    _s <- return _s{cur = _s.cur + 1}
    case yych of
        _c | 0x00 == _c -> do
            yy1 _s _cnt
        _c | 0x20 == _c -> do
            yy3 _s _cnt
        _c | 0x27 == _c -> do
            yy5 _s _cnt
        _c | True -> do
            yy2 _s _cnt

yy1 :: State -> Int -> IO Int
yy1 _s _cnt = do
#32 "haskell/eof/02_bounds_checking.re"
    -- check that it is the sentinel, not some unexpected null
    return $ if _s.cur == BS.length _s.buf - yymaxfill + 1 then _cnt else (-1)
#49 "haskell/eof/02_bounds_checking.hs"

yy2 :: State -> Int -> IO Int
yy2 _s _cnt = do
#38 "haskell/eof/02_bounds_checking.re"
    return (-1)
#55 "haskell/eof/02_bounds_checking.hs"

yy3 :: State -> Int -> IO Int
yy3 _s _cnt = do
    when (_s.lim - _s.cur < 1) $ throw UnexpectedFill
    yych <- return $ BS.index _s.buf _s.cur
    case yych of
        _c | 0x20 == _c -> do
            _s <- return _s{cur = _s.cur + 1}
            yy3 _s _cnt
        _c | True -> do
            yy4 _s _cnt

yy4 :: State -> Int -> IO Int
yy4 _s _cnt = do
#37 "haskell/eof/02_bounds_checking.re"
    lexer _s _cnt
#72 "haskell/eof/02_bounds_checking.hs"

yy5 :: State -> Int -> IO Int
yy5 _s _cnt = do
    when (_s.lim - _s.cur < 1) $ throw UnexpectedFill
    yych <- return $ BS.index _s.buf _s.cur
    _s <- return _s{cur = _s.cur + 1}
    case yych of
        _c | 0x27 == _c -> do
            yy6 _s _cnt
        _c | 0x5C == _c -> do
            yy7 _s _cnt
        _c | True -> do
            yy5 _s _cnt

yy6 :: State -> Int -> IO Int
yy6 _s _cnt = do
#36 "haskell/eof/02_bounds_checking.re"
    lexer _s (_cnt + 1)
#91 "haskell/eof/02_bounds_checking.hs"

yy7 :: State -> Int -> IO Int
yy7 _s _cnt = do
    when (_s.lim - _s.cur < 1) $ throw UnexpectedFill
    _s <- return _s{cur = _s.cur + 1}
    yy5 _s _cnt

lexer :: State -> Int -> IO Int
lexer _s _cnt = do
    yy0 _s _cnt

#39 "haskell/eof/02_bounds_checking.re"


main :: IO ()
main = do
    let test s n = do
            let buf = BS.concat [s, BS.replicate yymaxfill 0]
            let st = State {buf = buf, cur = 0, lim = BS.length buf}
            m <- catch (lexer st 0) (\(_ :: FillException) -> return (-2))
            when (m /= n) $ error "failed"

    test "" 0
    test "'unterminated\\'" (-2)
    test "'qu\0tes' 'are' 'fine: \\'' " 3
    test "'unexpected' \0 'null'" (-1)
