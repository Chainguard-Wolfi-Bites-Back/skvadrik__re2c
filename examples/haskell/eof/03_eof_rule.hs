-- Generated by re2c
#1 "haskell/eof/03_eof_rule.re"
-- re2hs $INPUT -o $OUTPUT
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}

import Control.Monad (when)
import Data.ByteString as BS
import Data.Word

data State = State {
    str :: BS.ByteString,
    cur :: Int,
    mar :: Int,
    lim :: Int
} deriving (Show)

-- expect a null-terminated string

#21 "haskell/eof/03_eof_rule.hs"
yy0 :: State -> Int -> Int
yy0 _s _cnt =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x20 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy3 _s _cnt
        _c | 0x27 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy5 _s _cnt
        _c | True ->
            if _s.cur >= _s.lim then
                yy10 _s _cnt
            else
                let _t = _s{cur = _s.cur + 1} in let _s = _t in
                yy1 _s _cnt

yy1 :: State -> Int -> Int
yy1 _s _cnt =
    yy2 _s _cnt

yy2 :: State -> Int -> Int
yy2 _s _cnt =
#30 "haskell/eof/03_eof_rule.re"
    (-1)
#47 "haskell/eof/03_eof_rule.hs"

yy3 :: State -> Int -> Int
yy3 _s _cnt =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x20 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy3 _s _cnt
        _c | True ->
            yy4 _s _cnt

yy4 :: State -> Int -> Int
yy4 _s _cnt =
#33 "haskell/eof/03_eof_rule.re"
    lexer _s _cnt
#63 "haskell/eof/03_eof_rule.hs"

yy5 :: State -> Int -> Int
yy5 _s _cnt =
    let _t = _s{mar = _s.cur} in let _s = _t in
    let yych = BS.index _s.str _s.cur in
    if yych <= 0x00 then
        if _s.cur >= _s.lim then
            yy2 _s _cnt
        else
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy6 _s _cnt
    else
        yy7 _s _cnt yych

yy6 :: State -> Int -> Int
yy6 _s _cnt =
    let yych = BS.index _s.str _s.cur in
    yy7 _s _cnt yych

yy7 :: State -> Int -> Word8 -> Int
yy7 _s _cnt yych =
    case yych of
        _c | 0x27 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy8 _s _cnt
        _c | 0x5C == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy9 _s _cnt
        _c | True ->
            if _s.cur >= _s.lim then
                yy11 _s _cnt
            else
                let _t = _s{cur = _s.cur + 1} in let _s = _t in
                yy6 _s _cnt

yy8 :: State -> Int -> Int
yy8 _s _cnt =
#32 "haskell/eof/03_eof_rule.re"
    lexer _s (_cnt + 1)
#103 "haskell/eof/03_eof_rule.hs"

yy9 :: State -> Int -> Int
yy9 _s _cnt =
    let yych = BS.index _s.str _s.cur in
    if yych <= 0x00 then
        if _s.cur >= _s.lim then
            yy11 _s _cnt
        else
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy6 _s _cnt
    else
        let _t = _s{cur = _s.cur + 1} in let _s = _t in
        yy6 _s _cnt

yy10 :: State -> Int -> Int
yy10 _s _cnt =
#31 "haskell/eof/03_eof_rule.re"
    _cnt
#122 "haskell/eof/03_eof_rule.hs"

yy11 :: State -> Int -> Int
yy11 _s _cnt =
    let _t = _s{cur = _s.mar} in let _s = _t in
    yy2 _s _cnt

lexer :: State -> Int -> Int
lexer _s _cnt =
    yy0 _s _cnt

#34 "haskell/eof/03_eof_rule.re"


main :: IO ()
main = do
    let test s n = do
            let st = State {
                    str = s,
                    cur = 0, 
                    mar = 0,
                    lim = BS.length s - 1 -- terminating null not included
                }
            when (lexer st 0 /= n) $ error "failed"

    test "\0" 0
    test "'qu\0tes' 'are' 'fine: \\'' \0" 3
    test "'unterminated\\'\0" (-1)
