-- Generated by re2c
{-# LANGUAGE RecordWildCards #-}
-- re2hs $INPUT -o $OUTPUT -i
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}

import Data.ByteString (ByteString, index)

data State = State {
    _str :: ByteString,
    _cur :: Int
}


yy0 :: State -> Bool
yy0 State{..} =
    let yych = index _str _cur in
    let __ = _cur + 1 in let _cur = __ in
    case yych of
        _c | 0x31 <= _c && _c <= 0x39 ->
            yy2 State{..}
        _c | True ->
            yy1 State{..}

yy1 :: State -> Bool
yy1 State{..} =
    False

yy2 :: State -> Bool
yy2 State{..} =
    let yych = index _str _cur in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let __ = _cur + 1 in let _cur = __ in
            yy2 State{..}
        _c | True ->
            yy3 State{..}

yy3 :: State -> Bool
yy3 State{..} =
    True

lexer :: State -> Bool
lexer State{..} =
    yy0 State{..}



main :: IO ()
main = case lexer State{_str = "1234\0", _cur = 0} of
    True -> return ()
    False -> error "lexer failed!"
