-- Generated by re2c
-- re2hs $INPUT -o $OUTPUT --header lexer/State.hs -i
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

import Data.ByteString as BS
import Control.Monad (when)
import State




yy0 :: State -> Int
yy0 State{..} =
    let yych = BS.index _str _cur in
    case yych of
        _c | 0x61 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy0 State{..}
        _c | 0x62 == _c ->
            let _t1 = _cur in
            let cur = _cur + 1 in let _cur = cur in
            yy2 State{..}
        _c | True ->
            let _t1 = _cur in
            yy1 State{..}

yy1 :: State -> Int
yy1 State{..} =
    let _tag = _t1 in
    _tag

yy2 :: State -> Int
yy2 State{..} =
    let yych = BS.index _str _cur in
    case yych of
        _c | 0x62 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy2 State{..}
        _c | True ->
            yy1 State{..}

lexer :: State -> Int
lexer State{..} =
    yy0 State{..}



main :: IO ()
main = do
    let s = State {
        _str = "ab\0",
        _cur = 0,
        
_t1 = -1,
        _tag = 0}

    when (lexer s /= 1) $ error "failed!"
-- Generated by re2c

module State where

import Data.ByteString as BS

data State = State {
    _str :: !BS.ByteString,
    _cur :: !Int,
    
_t1 :: !Int,
    _tag :: !Int
} deriving (Show)
haskell/headers/header.re:35:20: warning: rule matches empty string [-Wmatch-empty-string]
