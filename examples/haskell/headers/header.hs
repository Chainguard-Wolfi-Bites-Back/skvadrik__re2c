-- Generated by re2c
-- re2hs $INPUT -o $OUTPUT --header lexer/State.hs -i
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE OverloadedRecordDot #-}

import Data.ByteString as BS
import Control.Monad (when)
import State




yy0 :: State -> Int
yy0 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x61 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy0 _s
        _c | 0x62 == _c ->
            let _t = _s{yyt1 = _s.cur} in let _s = _t in
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy2 _s
        _c | True ->
            let _t = _s{yyt1 = _s.cur} in let _s = _t in
            yy1 _s

yy1 :: State -> Int
yy1 _s =
    let _t = _s{tag = _s.yyt1} in let _s = _t in
    _s.tag

yy2 :: State -> Int
yy2 _s =
    let yych = BS.index _s.str _s.cur in
    case yych of
        _c | 0x62 == _c ->
            let _t = _s{cur = _s.cur + 1} in let _s = _t in
            yy2 _s
        _c | True ->
            yy1 _s

lexer :: State -> Int
lexer _s =
    yy0 _s



main :: IO ()
main = do
    let s = State {
        str = "ab\0",
        cur = 0,
        
yyt1 = -1,
        tag = 0
    }
    when (lexer s /= 1) $ error "failed!"
-- Generated by re2c

module State where

import Data.ByteString as BS

data State = State {
    str :: !BS.ByteString,
    cur :: !Int,
    
yyt1 :: !Int,
    tag :: !Int
} deriving (Show)
haskell/headers/header.re:33:19: warning: rule matches empty string [-Wmatch-empty-string]
