// Code generated by re2c, DO NOT EDIT.
//line "v/fill/01_fill.re":1
// re2v $INPUT -o $OUTPUT

import os
import strings

const bufsize = 4096

struct State {
    file os.File
mut:
    str  []u8
    cur  int
    mar  int
    tok  int
    lim  int
    eof  bool
}

fn fill(mut st &State) int {
    if st.eof { return -1 } // unexpected EOF

    // Error: lexeme too long. In real life can reallocate a larger buffer.
    if st.tok < 1 { return -2 }

    // Shift buffer contents (discard everything up to the current token).
    copy(mut &st.str, st.str[st.tok..st.lim])
    st.cur -= st.tok
    st.mar -= st.tok
    st.lim -= st.tok
    st.tok = 0

    // Fill free space at the end of buffer with new data from file.
    pos := st.file.tell() or { 0 }
    if n := st.file.read_bytes_into(u64(pos), mut st.str[st.lim..bufsize]) {
        st.lim += n
    }
    st.str[st.lim] = 0 // append sentinel symbol

    // If read less than expected, this is the end of input.
    st.eof = st.lim < bufsize

    return 0
}

fn lex(mut yyrecord &State) int {
    mut count := 0
loop:
    yyrecord.tok = yyrecord.cur
    
//line "v/fill/01_fill.v":53
    mut yych := 0
yyFillLabel0:
    yych = yyrecord.str[yyrecord.cur]
    match yych {
        0x20 { unsafe { goto yy3 } }
        0x27 { unsafe { goto yy5 } }
        else {
            if yyrecord.lim <= yyrecord.cur {
                if fill(mut yyrecord) == 0 {
                    unsafe { goto yyFillLabel0 }
                }
                unsafe { goto yy10 }
            }
            unsafe { goto yy1 }
        }
    }
yy1:
    yyrecord.cur += 1
yy2:
//line "v/fill/01_fill.re":56
    return -1
//line "v/fill/01_fill.v":75
yy3:
    yyrecord.cur += 1
yyFillLabel1:
    yych = yyrecord.str[yyrecord.cur]
    match yych {
        0x20 { unsafe { goto yy3 } }
        else {
            if yyrecord.lim <= yyrecord.cur {
                if fill(mut yyrecord) == 0 {
                    unsafe { goto yyFillLabel1 }
                }
            }
            unsafe { goto yy4 }
        }
    }
yy4:
//line "v/fill/01_fill.re":59
    unsafe { goto loop }
//line "v/fill/01_fill.v":94
yy5:
    yyrecord.cur += 1
    yyrecord.mar = yyrecord.cur
yyFillLabel2:
    yych = yyrecord.str[yyrecord.cur]
    if yych >= 0x01 {
        unsafe { goto yy7 }
    }
    if yyrecord.lim <= yyrecord.cur {
        if fill(mut yyrecord) == 0 {
            unsafe { goto yyFillLabel2 }
        }
        unsafe { goto yy2 }
    }
yy6:
    yyrecord.cur += 1
yyFillLabel3:
    yych = yyrecord.str[yyrecord.cur]
yy7:
    match yych {
        0x27 { unsafe { goto yy8 } }
        0x5C { unsafe { goto yy9 } }
        else {
            if yyrecord.lim <= yyrecord.cur {
                if fill(mut yyrecord) == 0 {
                    unsafe { goto yyFillLabel3 }
                }
                unsafe { goto yy11 }
            }
            unsafe { goto yy6 }
        }
    }
yy8:
    yyrecord.cur += 1
//line "v/fill/01_fill.re":58
    count += 1; unsafe { goto loop }
//line "v/fill/01_fill.v":131
yy9:
    yyrecord.cur += 1
yyFillLabel4:
    yych = yyrecord.str[yyrecord.cur]
    if yych <= 0x00 {
        if yyrecord.lim <= yyrecord.cur {
            if fill(mut yyrecord) == 0 {
                unsafe { goto yyFillLabel4 }
            }
            unsafe { goto yy11 }
        }
        unsafe { goto yy6 }
    }
    unsafe { goto yy6 }
yy10:
//line "v/fill/01_fill.re":57
    return count
//line "v/fill/01_fill.v":149
yy11:
    yyrecord.cur = yyrecord.mar
    unsafe { goto yy2 }
//line "v/fill/01_fill.re":60

}

fn main() {
    fname := "input"
    content := "'qu\0tes' 'are' 'fine: \\'' ";

    // Prepare input file: a few times the size of the buffer, containing
    // strings with zeroes and escaped quotes.
    mut fw := os.create(fname)!
    fw.write_string(strings.repeat_string(content, bufsize))!
    fw.close()
    count := 3 * bufsize // number of quoted strings written to file

    // Prepare lexer state: all offsets are at the end of buffer.
    mut fr := os.open(fname)!
    mut st := &State{
        file: fr,
        // Sentinel at `lim` offset is set to zero, which triggers YYFILL.
        str:  []u8{len: bufsize + 1},
        cur:  bufsize,
        mar:  bufsize,
        tok:  bufsize,
        lim:  bufsize,
        eof:  false,
    }

    // Run the lexer.
    n := lex(mut st)
    if n != count { panic("expected $count, got $n") }

    // Cleanup: remove input file.
    fr.close()
    os.rm(fname)!
}
