// Code generated by re2c, DO NOT EDIT.
// re2v $INPUT -o $OUTPUT -ci

enum YYCONDTYPE {
    yycinit
    yycbin
    yycdec
    yychex
    yycoct
}


const u32_lim = u64(1) << 32

fn parse_u32(str string) ?u32 {
    mut cur, mut mar := 0, 0
    mut n := u64(0)
    mut cond := YYCONDTYPE.yycinit

    adddgt := fn (num u64, base u64, digit u8) u64 {
        n := num * base + u64(digit)
        return if n >= u32_lim { u32_lim } else { n }
    }

    
    mut yych := 0
    match cond {
        .yycinit { unsafe { goto yyc_init } }
        .yycbin { unsafe { goto yyc_bin } }
        .yycdec { unsafe { goto yyc_dec } }
        .yychex { unsafe { goto yyc_hex } }
        .yycoct { unsafe { goto yyc_oct } }
    }
/* *********************************** */
yyc_init:
    yych = str[cur]
    match yych {
        0x30 { unsafe { goto yy2 } }
        0x31...0x39 { unsafe { goto yy4 } }
        else { unsafe { goto yy1 } }
    }
yy1:
    cur += 1
    return none
yy2:
    cur += 1
    mar = cur
    yych = str[cur]
    match yych {
        0x42, 0x62 { unsafe { goto yy5 } }
        0x58, 0x78 { unsafe { goto yy7 } }
        else { unsafe { goto yy3 } }
    }
yy3:
    cond = .yycoct
    unsafe { goto yyc_oct }
yy4:
    cur += 1
    cur += -1
    cond = .yycdec
    unsafe { goto yyc_dec }
yy5:
    cur += 1
    yych = str[cur]
    match yych {
        0x30...0x31 { unsafe { goto yy8 } }
        else { unsafe { goto yy6 } }
    }
yy6:
    cur = mar
    unsafe { goto yy3 }
yy7:
    cur += 1
    yych = str[cur]
    match yych {
        0x30...0x39, 0x41...0x46, 0x61...0x66 { unsafe { goto yy9 } }
        else { unsafe { goto yy6 } }
    }
yy8:
    cur += 1
    cur += -1
    cond = .yycbin
    unsafe { goto yyc_bin }
yy9:
    cur += 1
    cur += -1
    cond = .yychex
    unsafe { goto yyc_hex }
/* *********************************** */
yyc_bin:
    yych = str[cur]
    match yych {
        0x00 { unsafe { goto yy11 } }
        0x30...0x31 { unsafe { goto yy13 } }
        else { unsafe { goto yy12 } }
    }
yy11:
    cur += 1
    return if n < u32_lim { u32(n) } else { none }
yy12:
    cur += 1
    return none
yy13:
    cur += 1
    n = adddgt(n, 2,  str[cur-1] - 48); unsafe{ goto yyc_bin }
/* *********************************** */
yyc_dec:
    yych = str[cur]
    match yych {
        0x00 { unsafe { goto yy15 } }
        0x30...0x39 { unsafe { goto yy17 } }
        else { unsafe { goto yy16 } }
    }
yy15:
    cur += 1
    return if n < u32_lim { u32(n) } else { none }
yy16:
    cur += 1
    return none
yy17:
    cur += 1
    n = adddgt(n, 10, str[cur-1] - 48); unsafe{ goto yyc_dec }
/* *********************************** */
yyc_hex:
    yych = str[cur]
    match yych {
        0x00 { unsafe { goto yy19 } }
        0x30...0x39 { unsafe { goto yy21 } }
        0x41...0x46 { unsafe { goto yy22 } }
        0x61...0x66 { unsafe { goto yy23 } }
        else { unsafe { goto yy20 } }
    }
yy19:
    cur += 1
    return if n < u32_lim { u32(n) } else { none }
yy20:
    cur += 1
    return none
yy21:
    cur += 1
    n = adddgt(n, 16, str[cur-1] - 48); unsafe{ goto yyc_hex }
yy22:
    cur += 1
    n = adddgt(n, 16, str[cur-1] - 55); unsafe{ goto yyc_hex }
yy23:
    cur += 1
    n = adddgt(n, 16, str[cur-1] - 87); unsafe{ goto yyc_hex }
/* *********************************** */
yyc_oct:
    yych = str[cur]
    match yych {
        0x00 { unsafe { goto yy25 } }
        0x30...0x37 { unsafe { goto yy27 } }
        else { unsafe { goto yy26 } }
    }
yy25:
    cur += 1
    return if n < u32_lim { u32(n) } else { none }
yy26:
    cur += 1
    return none
yy27:
    cur += 1
    n = adddgt(n, 8,  str[cur-1] - 48); unsafe{ goto yyc_oct }

}

fn main() {
    test := fn (num ?u32, str string) {
        if n := parse_u32(str) {
            if m := num { if n != m { panic("wrong number") } }
        } else {
            if _ := num { panic("expected none") }
        }
    }
    test(1234567890, "1234567890\0")
    test(13, "0b1101\0")
    test(0x7fe, "0x007Fe\0")
    test(0o644, "0644\0")
    test(none, "9999999999\0")
    test(none, "123??\0")
}
