// Code generated by re2c, DO NOT EDIT.
// re2v $INPUT -o $OUTPUT -i

const u32_lim = u64(1) << 32

fn parse_u32(str string) ?u32 {
    mut cur, mut mar := 0, 0
    mut n := u64(0)
    mut yych := 0

    adddgt := fn (num u64, base u64, digit u8) u64 {
        n := num * base + u64(digit)
        return if n >= u32_lim { u32_lim } else { n }
    }
    
    yych = str[cur]
    match yych {
        0x30 { unsafe { goto yy2 } }
        0x31...0x39 { unsafe { goto yy4 } }
        else { unsafe { goto yy1 } }
    }
yy1:
    cur += 1
    return none
yy2:
    cur += 1
    mar = cur
    yych = str[cur]
    match yych {
        0x42, 0x62 { unsafe { goto yy5 } }
        0x58, 0x78 { unsafe { goto yy7 } }
        else { unsafe { goto yy3 } }
    }
yy3:
    unsafe{ goto oct }
yy4:
    cur += 1
    cur += -1
    unsafe{ goto dec }
yy5:
    cur += 1
    yych = str[cur]
    match yych {
        0x30...0x31 { unsafe { goto yy8 } }
        else { unsafe { goto yy6 } }
    }
yy6:
    cur = mar
    unsafe { goto yy3 }
yy7:
    cur += 1
    yych = str[cur]
    match yych {
        0x30...0x39, 0x41...0x46, 0x61...0x66 { unsafe { goto yy9 } }
        else { unsafe { goto yy6 } }
    }
yy8:
    cur += 1
    cur += -1
    unsafe{ goto bin }
yy9:
    cur += 1
    cur += -1
    unsafe{ goto hex }

bin:
    
    yych = str[cur]
    match yych {
        0x00 { unsafe { goto yy11 } }
        0x30...0x31 { unsafe { goto yy13 } }
        else { unsafe { goto yy12 } }
    }
yy11:
    cur += 1
    unsafe{ goto end }
yy12:
    cur += 1
    return none
yy13:
    cur += 1
    n = adddgt(n, 2, str[cur-1] - 48); unsafe{ goto bin }

oct:
    
    yych = str[cur]
    match yych {
        0x00 { unsafe { goto yy15 } }
        0x30...0x37 { unsafe { goto yy17 } }
        else { unsafe { goto yy16 } }
    }
yy15:
    cur += 1
    unsafe{ goto end }
yy16:
    cur += 1
    return none
yy17:
    cur += 1
    n = adddgt(n, 8, str[cur-1] - 48); unsafe{ goto oct }

dec:
    
    yych = str[cur]
    match yych {
        0x00 { unsafe { goto yy19 } }
        0x30...0x39 { unsafe { goto yy21 } }
        else { unsafe { goto yy20 } }
    }
yy19:
    cur += 1
    unsafe{ goto end }
yy20:
    cur += 1
    return none
yy21:
    cur += 1
    n = adddgt(n, 10, str[cur-1] - 48); unsafe{ goto dec }

hex:
    
    yych = str[cur]
    match yych {
        0x00 { unsafe { goto yy23 } }
        0x30...0x39 { unsafe { goto yy25 } }
        0x41...0x46 { unsafe { goto yy26 } }
        0x61...0x66 { unsafe { goto yy27 } }
        else { unsafe { goto yy24 } }
    }
yy23:
    cur += 1
    unsafe{ goto end }
yy24:
    cur += 1
    return none
yy25:
    cur += 1
    n = adddgt(n, 16, str[cur-1] - 48); unsafe{ goto hex }
yy26:
    cur += 1
    n = adddgt(n, 16, str[cur-1] - 55); unsafe{ goto hex }
yy27:
    cur += 1
    n = adddgt(n, 16, str[cur-1] - 87); unsafe{ goto hex }

end:
    if n < u32_lim {
        return u32(n)
    }
    return none
}

fn main() {
    test := fn (num ?u32, str string) {
        if n := parse_u32(str) {
            if m := num { if n != m { panic("wrong number") } }
        } else {
            if _ := num { panic("expected none") }
        }
    }
    test(1234567890, "1234567890\0")
    test(13, "0b1101\0")
    test(0x7fe, "0x007Fe\0")
    test(0o644, "0644\0")
    test(none, "9999999999\0")
    test(none, "123??\0")
}
