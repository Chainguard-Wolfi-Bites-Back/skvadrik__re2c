// Code generated by re2c, DO NOT EDIT.
// re2v $INPUT -o $OUTPUT -i --header lexer/state.v
module main

import lexer // the package is generated by re2c



fn lex(mut st &lexer.State) int {
    mut t := 0
    
    mut yych := 0
    unsafe { goto yy0 }
yy1:
    st.cur++
yy0:
    yych = st.data[st.cur]
    match yych {
        0x61 { unsafe { goto yy1 } }
        0x62 {
            st.yyt1 = st.cur
            unsafe { goto yy3 }
        }
        else {
            st.yyt1 = st.cur
            unsafe { goto yy2 }
        }
    }
yy2:
    t = st.yyt1
    return t
yy3:
    st.cur++
    yych = st.data[st.cur]
    match yych {
        0x62 { unsafe { goto yy3 } }
        else { unsafe { goto yy2 } }
    }

}

fn main() {
    mut st := &lexer.State{data:"ab\0",}
    if lex(mut st) != 1 {
        panic("error")
    }
}
// Code generated by re2c, DO NOT EDIT.

module lexer

pub struct State {
pub mut:
    data string
    cur  int
    yyt1 int

}
v/headers/header.re:29:21: warning: rule matches empty string [-Wmatch-empty-string]
