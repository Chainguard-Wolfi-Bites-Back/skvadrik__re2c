/* Generated by re2c */
#line 1 "d/submatch/01_stags_fill.re"
// re2d $INPUT -o $OUTPUT --tags
module main;

import core.stdc.string;
import core.stdc.stdio;
import std.stdio;

enum BUFSIZE = 4095;

struct Input {
    FILE* file;
    char[BUFSIZE + 1] str;// +1 for sentinel
    char* lim, cur, mar, tok;
    // Tag variables must be part of the lexer state passed to YYFILL.
    // They don't correspond to tags and should be autogenerated by re2c.
    
#line 20 "d/submatch/01_stags_fill.d"
char* yyt1;char* yyt2;char* yyt3;
#line 16 "d/submatch/01_stags_fill.re"

    bool eof;
};

struct SemVer {
    int major;
    int minor;
    int patch;
};

private int s2n(const(char)* s, const(char)* e) { // pre-parsed string to number
    int n = 0;
    for (; s < e; ++s) n = n * 10 + (*s - '0');
    return n;
}

private int fill(ref Input input) {
    if (input.eof) return 1;

    const size_t shift = input.tok - input.str.ptr;
    const size_t used = input.lim - input.tok;

    // Error: lexeme too long. In real life could reallocate a larger buffer.
    if (shift < 1) return 2;

    // Shift buffer contents (discard everything up to the current token).
    memmove(cast(void*)input.str.ptr, input.tok, used);
    input.lim -= shift;
    input.cur -= shift;
    input.mar -= shift;
    input.tok -= shift;
    // Tag variables need to be shifted like other input positions. The check
    // for non-null is only needed if some tags are nested inside of alternative
    // or repetition, so that they can have null value.
    
#line 58 "d/submatch/01_stags_fill.d"
if (input.yyt1) input.yyt1 -= shift;
if (input.yyt2) input.yyt2 -= shift;
if (input.yyt3) input.yyt3 -= shift;
#line 50 "d/submatch/01_stags_fill.re"


    // Fill free space at the end of buffer with new data from file.
    input.lim += fread(input.lim, 1, BUFSIZE - used, input.file);
    input.lim[0] = 0;
    input.eof = input.lim < (input.str.ptr + BUFSIZE);
    return 0;
}

private bool lex(ref Input yyrecord, ref SemVer[] vers) {
    // User-defined local variables that store final tag values.
    // They are different from tag variables autogenerated with `stags:re2c`,
    // as they are set at the end of match and used only in semantic actions.
    char* t1, t2, t3, t4;
    for (;;) {
        yyrecord.tok = yyrecord.cur;
    
#line 80 "d/submatch/01_stags_fill.d"
{
	char yych;
yyFillLabel0:
	yych = *yyrecord.cur;
	switch (yych) {
		case '0': .. case '9': goto yy3;
		default:
			if (yyrecord.lim <= yyrecord.cur) {
				if (fill(yyrecord) == 0) goto yyFillLabel0;
				goto yy11;
			}
			goto yy1;
	}
yy1:
	++yyrecord.cur;
yy2:
#line 83 "d/submatch/01_stags_fill.re"
	{ return false; }
#line 99 "d/submatch/01_stags_fill.d"
yy3:
	++yyrecord.cur;
	yyrecord.mar = yyrecord.cur;
yyFillLabel1:
	yych = *yyrecord.cur;
	switch (yych) {
		case '.': goto yy4;
		case '0': .. case '9': goto yy6;
		default:
			if (yyrecord.lim <= yyrecord.cur) {
				if (fill(yyrecord) == 0) goto yyFillLabel1;
			}
			goto yy2;
	}
yy4:
	++yyrecord.cur;
yyFillLabel2:
	yych = *yyrecord.cur;
	switch (yych) {
		case '0': .. case '9':
			yyrecord.yyt1 = yyrecord.cur;
			goto yy7;
		default:
			if (yyrecord.lim <= yyrecord.cur) {
				if (fill(yyrecord) == 0) goto yyFillLabel2;
			}
			goto yy5;
	}
yy5:
	yyrecord.cur = yyrecord.mar;
	goto yy2;
yy6:
	++yyrecord.cur;
yyFillLabel3:
	yych = *yyrecord.cur;
	switch (yych) {
		case '.': goto yy4;
		case '0': .. case '9': goto yy6;
		default:
			if (yyrecord.lim <= yyrecord.cur) {
				if (fill(yyrecord) == 0) goto yyFillLabel3;
			}
			goto yy5;
	}
yy7:
	++yyrecord.cur;
yyFillLabel4:
	yych = *yyrecord.cur;
	switch (yych) {
		case '\n':
			yyrecord.yyt2 = yyrecord.cur;
			yyrecord.yyt3 = null;
			goto yy8;
		case '.':
			yyrecord.yyt2 = yyrecord.cur;
			goto yy9;
		case '0': .. case '9': goto yy7;
		default:
			if (yyrecord.lim <= yyrecord.cur) {
				if (fill(yyrecord) == 0) goto yyFillLabel4;
			}
			goto yy5;
	}
yy8:
	++yyrecord.cur;
	t2 = yyrecord.yyt1;
	t3 = yyrecord.yyt2;
	t4 = yyrecord.yyt3;
	t1 = yyrecord.yyt1;
	t1 -= 1;
#line 74 "d/submatch/01_stags_fill.re"
	{
            int major = s2n(yyrecord.tok, t1);
            int minor = s2n(t2, t3);
            int patch = t4 != null ? s2n(t4, yyrecord.cur - 1) : 0;
            SemVer ver = SemVer(major, minor, patch);
            vers ~= ver;
            continue;
        }
#line 179 "d/submatch/01_stags_fill.d"
yy9:
	++yyrecord.cur;
yyFillLabel5:
	yych = *yyrecord.cur;
	switch (yych) {
		case '0': .. case '9':
			yyrecord.yyt3 = yyrecord.cur;
			goto yy10;
		default:
			if (yyrecord.lim <= yyrecord.cur) {
				if (fill(yyrecord) == 0) goto yyFillLabel5;
			}
			goto yy5;
	}
yy10:
	++yyrecord.cur;
yyFillLabel6:
	yych = *yyrecord.cur;
	switch (yych) {
		case '\n': goto yy8;
		case '0': .. case '9': goto yy10;
		default:
			if (yyrecord.lim <= yyrecord.cur) {
				if (fill(yyrecord) == 0) goto yyFillLabel6;
			}
			goto yy5;
	}
yy11:
#line 82 "d/submatch/01_stags_fill.re"
	{ return true; }
#line 210 "d/submatch/01_stags_fill.d"
}
#line 84 "d/submatch/01_stags_fill.re"

    }
    assert(0);
}

void main() {
    const char[] fname = "input";
    const char[] content = "1.22.333\n' ";

    SemVer[BUFSIZE] expect = SemVer(1, 22, 333);
    SemVer[] actual;

    // Prepare input file: a few times the size of the buffer, containing
    // strings with zeroes and escaped quotes.
    FILE* f = fopen(fname.ptr, "w");
    for (int i = 0; i < BUFSIZE; ++i) {
        fwrite(cast(const(void*)) content.ptr, 1, content.length - 2, f); // skip null-terminator
    }
    fclose(f);

    // Initialize lexer state: all pointers are at the end of buffer.
    Input input;
    input.file = fopen(fname.ptr, "r");
    input.cur = input.mar = input.tok = input.lim = input.str.ptr + BUFSIZE;
    input.eof = 0;
    // Sentinel (at YYLIMIT pointer) is set to zero, which triggers YYFILL.
    input.lim[0] = 0;

    // Run the lexer.
    assert(lex(input, actual) && actual == expect);

    // Cleanup: remove input file.
    fclose(input.file);
    remove(fname.ptr);
}
